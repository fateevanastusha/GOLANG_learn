package main

import "fmt"

/*
	Garbage collector
	Для чего нужен?
	- удалять объекта, на которые никто больше не ссылается

	Алгоритмы:
	1) mark-sweep collection
	- имеет две фазы: маркировка и очищение.
	Берет корень, ищет все ссылки из него и помечает их как живые. Находит объекты, до которых не смог добраться,
	удаляет их (они не помечены как живые). Не меняет адреса у переменных, и куча остается довольно большой.
	[■][□][■][□][■][■] (прозрачные - мертвые)
	Получается фрагментация.
	2) copying collection
	Берет корень, помечает все живые объекты, до которых может построить путь. Меняет адреса у переменных так, что
	она становится компактной (перемещает все мертвые в конец). Все те же плюсы из mark-sweep, плюс никакой фрагментации.
	[■][■][■][■][□][□]
	Компактизация кучи стоит ресурсов машины.
	3) mark-compact collection
	- делит память на FROM и TO. Живые объекты просто плотно копирует в TO (то есть никакой фрагментации). На следующей
	фазе будет делать обратное действие - копировать из TO в FROM (тоже плотно только живые объекты). То есть он копирует
	кучу туда-сюда. Требует в 2 раза больше памяти соответственно.
	FROM           TO
	[□]            [■]
	[□]            [■]
	[□]    --->    [■]
	[□]            [□]
	[□]            [□]

	FROM           TO
	[■]            [□]
	[■]            [□]
	[■]    <---    [□]
	[□]            [□]
	[□]            [□]
	4) reference counting
	- подсчитывает сколько раз ссылаются на каждый объект. Когда больше никто не ссылается - counter уменьшается. Если он
	равен 0, то он удаляется. Есть проблема - циклическая зависимость (когда объекты указываются друг на друга), то есть он
	не сможет удалить их. Минусы - counter тратит много ресурсов.

	или комбинации этих алгоритмов.

	В GO есть механизм - либо мы используем много ОЗУ, либо много постоянной памяти. Использовать мало одновременно - нельзя.



	В GOLANG используется MARK-SWEEP, но у него три вида объектов -
	1) те, что надо удалить (белый)
	2) те, над которыми надо подумать (серый)
	3) те, что не надо удалять (черный)
	Он берет корень, помечает его черным, и смотрит все, что на него ссылается. Он помечает их серым и добавляет их в очередь
	серых объектов. Дальше он достает из очереди серые объекты, помечает их либо черным, либо белым (в зависимости от того,
	ссылается ли на них кто-то).
	Это все делают горутины на фоне основной программы.

	     ●         ← корень (root) — уже помечен (черный)
        / \
      o     o      ← помечены серым (дочерние)
     /       \
   (3)       (5)   ← ещё не помечены (белые)
    |
   (4)         ← этот узел есть внизу, но не связан (по структуре)




*/

/*
	go run -gcflags="-m" main.go
	- запустит логи информации о том, куда перемещаются переменные (в стэк или в кучу)
*/

func kek() *int {
	a := 0
	/*
		./garbage_collector.go:74:6: can inline kek
		./garbage_collector.go:84:6: can inline main
		./garbage_collector.go:80:10: inlining call to kek
		./garbage_collector.go:81:13: inlining call to fmt.Println
		./garbage_collector.go:81:13: ... argument does not escape
		./garbage_collector.go:81:14: a escapes to heap
		0
		-
	*/
	// return a
	/*
		./garbage_collector.go:74:6: can inline kek
		./garbage_collector.go:94:6: can inline main
		./garbage_collector.go:81:10: inlining call to kek
		./garbage_collector.go:82:13: inlining call to fmt.Println
		./garbage_collector.go:75:2: moved to heap: a
		./garbage_collector.go:81:10: moved to heap: a
		./garbage_collector.go:82:13: ... argument does not escape
		0x1400000e0c0
	*/
	return &a
}

func useKek() {
	a := kek()
	fmt.Println(a)
}

/*
	runtime библиотека содержит в себе garbage collector (mgc.go).
	GC запускается конкуретно с горутинами из пользовательского кода. Он не использует молодые/старые поколения и оставляет фрагментацию (зато не меняет
	адреса ячеек памяти). По сути он использует алгоритм Дейкстры! Этапы GC:
	1) stop the world (останавливает все горутины, чтобы они дождались очистки мусора)
	2) фаза маркировки
		а) маркирует
		б) start the world
		с) маркирует корки
		д)
	3)
*/

func main() {
	fmt.Println("---------------------------------------------------------------------------------------------------------------------------------------------")
	fmt.Println("USE_KEK()")
	useKek()
	fmt.Println("---------------------------------------------------------------------------------------------------------------------------------------------")
	fmt.Println("USE_KEK()")
}
