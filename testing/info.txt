       [ E2E ]
     [INTEGRATION]
   [     UNIT      ]

1) 
Unit-тесты проверяют работу отдельной единицы кода — функции, метода или класса — в изоляции от остальной системы. 
Они не взаимодействуют с внешними зависимостями, такими как база данных, файловая система или сеть.

Пример:
Тест функции, которая сортирует массив, или метода, который вычисляет налог по заданной ставке.

Плюсы:
	•	Быстрые в исполнении.
	•	Дешёвые в разработке и поддержке.
	•	Легко отлаживать: если упал unit-тест, проблема локализована.
	•	Позволяют быстро найти и исправить ошибку в логике.

Минусы:
	•	Не гарантируют, что компоненты системы правильно работают вместе.
	•	Не покрывают реальные сценарии взаимодействия пользователя.

Гарантии:
	•	Проверка корректности бизнес-логики на самом базовом уровне.


2) integration -
Интеграционные тесты проверяют взаимодействие нескольких модулей между собой. Это может быть как связь двух классов, 
так и работа сервиса с базой данных, API, файловой системой и т.д.

Пример:
Тест, который создает пользователя и проверяет, что он был сохранён в базе данных и возвращается через API.

Плюсы:
	•	Позволяют протестировать реальные зависимости.
	•	Выявляют проблемы на стыке компонентов (например, неверная сериализация, ошибки в запросах к БД).

Минусы:
	•	Медленнее unit-тестов.
	•	Сложнее в поддержке: при изменении интерфейсов или зависимостей тесты могут ломаться.
	•	Могут быть нестабильными из-за внешней среды (например, медленная БД или нестабильная сеть).

Гарантии:
	•	Проверка, что части системы взаимодействуют корректно, как задумывалось.


3) e2e -
E2E-тесты имитируют поведение реального пользователя, проходящего сквозь всю систему. Они запускаются в максимально приближенной 
к “боевой” среде: фронтенд, бэкенд, база данных, очередь сообщений, внешние сервисы и т.д.

Пример:
Тест, который открывает браузер, заполняет форму заказа, нажимает кнопку “Оформить”, проверяет, что заказ появился в админке и
пользователь получил email с подтверждением.

Плюсы:
	•	Проверяют всю цепочку: от UI до базы данных и обратно.
	•	Отлично подходят для критических сценариев.
	•	Показывают, как работает система глазами пользователя.

Минусы:
	•	Очень медленные.
	•	Дорогие в написании и сопровождении.
	•	Часто нестабильны из-за различий между dev/staging/prod окружениями.
	•	Сложны в отладке: ошибка может быть где угодно в цепочке.

Гарантии:
	•	Высокий уровень уверенности в том, что пользовательский сценарий работает от начала до конца.


Layers  

Devices / Web / DB / UI / External services
\/
Gateways / Controllers / Presenters (уровень, где принимаем входящие запросы, валидируем их, перекладываем в бизнес логику)
\/
Use Cases (бизнес логика)
\/
Entities (сущности, в которые мы что-то слкадываем и передаем их между слоями)



Test doubles (тестовые двойники)

1) fake 
- упрощенная реализация функционала
пример: написать репозиторий, удовлетворяющий интерфейсу, где не будет реального обращения в базу, вместо этого
какая-нибудь хэш таблица

2) mock
- можно создать некоторый интерфейс и говорить ему как он должен действовать. Может эмулировать отдачу ошибки,
отдачу успеха и тд. Можем чекать, сколько раз вызван данный метод. 

3) stub 
- упрощенное решение, соответствующее интерфейсу и дающее всегда статичный ответ. Может быть полезно для простых
сценариев