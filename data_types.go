package main

func main() {

	/*
		ТИПЫ ДАННЫХ
	*/

	/*
		СИМВОЛ
		- для их хранения используют обычно rune или int32. Символы заключаются в одинарные кавычки, а компилятор автоматически
		преобразует их в код символа по стандарту Unicode. Например, вместо символа 'c' в памяти будет храниться числовое значение
		99. Для преобразования этого числового значения обратно в символ можно использовать функцию string():

		var symbol int32 = 'c'
		fmt.Println(string(symbol))  // Вывод: c
	*/

	/*

		ЦЕЛОЧИСЛЕННЫЕ ТИПЫ

		(signed integer) int_
		int8 (от -128 до 127), занимает 8 бит
		int16 (от -32768 до 32767), занимает 16 бит
		int32 (от -2147483648 до 2147483647), занимает 32 бита
		int64 (от –9 223 372 036 854 775 808 до 9 223 372 036 854 775 807), занимает 64 бита
		- число. Число после значит какое количество байт в памяти может занимать переменная.



		(unsigned integer) uint_ (uint8, uint16, uint32, uint64)
		uint8 (от 0 до 255), занимает 8 бит
		uint16 (от 0 до 65535), занимает 16 бит
		uint32 (от 0 до 4294967295), занимает 32 бита
		uint64 (от 0 до 18 446 744 073 709 551 615), занимает 64 бита
		- целое число, которое не может быть отрицательным



		byte = uint8 (от 0 до 255), занимает 8 бит


		rune = int32 (от -2147483648 до 2147483647), занимает 32 бита



		МАШИННО-ЗАВИСИМЫЕ ЦЕЛОЧИСЛЕННЫЕ ТИПЫ:

		int = либо int32, либо int64 (в зависимости от платформы), занимает либо 32 бита, либо 64 бита


		uint = либо uint32, либо uint64 (в зависимости от платформы), занимает либо 32 бита, либо 64 бита



		uintptr = k



		var a int8 = -1
		var b uint8 = 2
		var c byte = 3  // byte - синоним типа uint8
		var d int16 = -4
		var f uint16 = 5
		var g int32 = -6
		var h rune = -7     // rune - синоним типа int32
		var j uint32 = 8
		var k int64 = -9
		var l uint64 = 10
		var m int = 102
		var n uint = 105
	*/

	/*
		ЧИСЛА С ПЛАВАЮЩЕЙ ТОЧКОЙ

		float_ (32, 64)
		float32 (от −3.4028235E+38 до 3.4028235E+38), занимает 32 бита - точность 7 знаков после запятой
		float64 (от −1.7976931348623157E+308 до 1.7976931348623157E+308), занимает 64 бита - точность 15 знаков после запятой


		так же существуют комплексные числа:
		complex64
		complex128


		var a float32 = 3.05
		var b float64 = 3.1484205843
	*/

	/*
		Специальные обозначения:

		1) NaN (Not a Number)
		— например, результат операции вроде 0/0.
		2) Положительная и отрицательная бесконечность (+∞ и −∞).
	*/

	/*
		СТРОКИ

		string
		- является неизменяемым, нельзя изменить содержание после создания. Хранятся в виде байтов.

		С помощью двойных кавычек: "Hello World".
		"" - не могут содержать переносы на новую строку, но поддерживают специальные управляющие последовательности (\n, \t).
		С помощью обратных апострофов: `Hello World`.
		`` -  могут содержать переносы строк и игнорируют управляющие последовательности (\n, \t), отображая их как обычный текст.

		var a string = "hi!"

		1) Подсчёт байтов строки:
		len("Hello World")

		2) Доступ к символу по индексу:
		"Hello World"[1]

		3) Конкатенация строк:
		"Hello " + "World" = "Hello World"

		4) Так как строки в Go хранятся в виде байтов нужно понимать что такой код не выведет символ:

		package main

		import "fmt"

		func main() {
			fmt.Println("Hello Go"[0]) // вывод: 72
			fmt.Println(string("Hello Go"[0])) // вывод: H
		}
	*/

	/*
		ЛОГИЧЕСКИЙ ТИП ДАННЫХ

		bool
		- может быть true или false

		var isTrue bool = true
	*/

	/*
		СОСТАВНЫЕ ТИПЫ ДАННЫХ

		массивы
		- нужно указать количество элементов в массиве в скобках и затем тип элемента. По умолчанию изначально массив
		будет заполнен нулями (в том количестве, которое указали в скобках)

		var а [5]int = [5]int{1,2,3,4,5}

		можно обратиться к элементам через скобки
		a[0] = 1
		a[4] = 5



		срезы
		- это динамические последовательности элементов одного типа. Не имеют фиксированной длины, поэтому их размер
		может корректироваться.

		var a []string = []string{“John”, ”Alice”, ”Bob”}

		1) можно обратиться к элементам через скобки:

		a[1] = "Alice"
		a[0] = "John"

		2) можно создать срез заданной длины:
		var a []int = make([]int, 3)



		структуры
		- составной тип данных, который позволяет объеденить несколько переменных разных типов в один объект. Могут
		содержать поля любых типов данных, даже другие структуры.

		1) объявить структуру можно так:
		type Person struct {
			Name    string
			Age     int
			Address string
		}

		2) создать переменную так:
		var Tom Person = Person{"Tom", 23, "123 Broadway Street"}

		3) можно обратиться к полям:
		Tom.Age = 23



		Карты
		- неупорядоченный набор пар ключ-значение. Ключи и значения могут быть любого типа, но каждый ключ должен
		быть уникальным.

		var m map[keyType]valueType

		keyType — тип данных для ключа,
		valueType — тип данных для значения.

		1) создать карту:
		var m map[string]int

		2) добавить элемент:
		m[key] = value

		m["apple"] = 1
		m["banana"] = 2
		m["orange"] = 3

		3) получить элемент:
		value := m[key]

		fmt.Println(m["apple"])

		4) проверить, существует ли ключ:
		value, ok := m[key]
		если существует, то в переменной ok будет лежать значение true (false если не существует)

		5) удалить элемент:
		delete(m, "banana")

	*/

	/*
		УКАЗАТЕЛИ И ИНТЕРФЕЙСЫ

		Указатели
		- это переменные, которые хранят адрес памяти другой переменной.

		var p *type

		type — тип данных, на который ссылается указатель.

		указатель на переменную int:
		var p *int

		1) получить адрес переменой:
		var x int = 10
		p := &x - указатель p содержит адрес переменной x.


		2) получить значени переменной, на которую ссылается указатель:
		var x int = 10
		p := &x
		fmt.Println(*p)



		Интерфейсы
		- определяют набор методов, которые должны быть реализованы в типах данных. Позволяют абстрагироваться
		от конкретных типов данных и реализовывать полиморфизм. Для создания интерфейса нужно определить набор
		методов, которые должен реализовать тип данных.

		type MyInterface interface {
			Method1([]byte) (int, error)
		}

		- определили интерфейс MyInterface с методом Method1 и аргументом типа []byte. Он будет возвращать количество
		записанных байтов и ошибку.

	*/

	/*
		АРИФМЕТИЧЕСКИЕ ОПЕРАЦИИ

		+ сложение
		- вычитание
		* умножение
		/ деление
		% получить остаток от деления


	*/

	a := 100
	b := 10

	c := a + b // с = 110
	c = a * b  // с = 1000
	c = a - b  // с = 90
	c = a / b  // с = 10
	с = 10 % 3 // c = 1

	//При делении стоит быть внимательным, так как результат округляется до целого числа
	var e int = 10 / 6 //1
	//Чтобы получить вещественное число, как минимум одно из двух должно быть вещественным + куда присваеваем тоже
	var m float32 = 10.0 / 6 //1.666666

	//Прибавить или убавить можно по-другому:
	var k int = 1
	k++ //k = 2
	k-- //k = 1

}
