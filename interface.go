package main

import "fmt"

type Dog struct {
	Name string
}

func (d *Dog) Speak() string {
	return "Гав! Меня зовут " + d.Name
}

func main() {
	/*
		ИНТЕРФЕЙС - это специальный тип, который определяет набор сигнатур методов, но не содержит их реализацию.
		Интерфейсы позволяют описывать поведение структур, что делает код более гибким. Структуры могут НЕЯВНО
		реализовывать интерфейсы. Интерфейсы позволяют писать гибкий и расширяемый код, который работает с абстракциями,
		а не с конкретными структурами.
	*/

	//1) объявление интерфейсов

	type MyInterface interface {
		MyMethod()
	}

	//2) встраивание интерфейсов (типа extends)

	type I interface {
		MyInterface
	}

	//3) переменная интерфейсного типа
	/*
		Когда ты присваиваешь что-то переменной интерфейсного типа, Go не просто сохраняет значение, а делает две вещи
		одновременно:
		1.	Запоминает конкретный тип (например, Dog, int, string, *User и т.п.)
		2.	Сохраняет само значение этого типа
		можно рассматривать как кортеж (пару) из значения и конкретного типа:

		(value, type)
		type - конкретный тип данных, к которому принадлежит значение. Например, это может быть строка (string), число
		(int), структура (struct) или любой другой тип. Тип определяет, какие методы доступны для вызова на этом
		значении.
		value - конкретное значение, которое принадлежит определенному базовому типу. Например, это может быть строка
		"Hello", число 123 или экземпляр структуры, такой как Dog.
	*/

	type Animal interface {
		Speak() string
	}
	var animal Animal
	fmt.Printf("Value %v, type %T\n", animal, animal) //Value <nil>, type <nil>
	//Это означает, что переменная animal не содержит никаких свойств и не указывает на конкретный тип (структуру).

	if animal != nil {
		fmt.Println("animal is not nil") //никогда не распечатается
	}

	dog := &Dog{} //указатель на новый объект Dog
	animal = dog
	animal.Speak()                                    //можем вызвать, так как dog реализует этот метод (то есть имплементирует интерфейс)
	fmt.Printf("Value %v, type %T\n", animal, animal) //Value &{}, type *main.Dog - теперь тип указывает на Dog

	if animal != nil {
		fmt.Println("animal is not nil") //распечатается
	}
	// Поскольку animal указывает на объект Dog, условие выполняется, и выводится сообщение "animal is not nil".

	dog.Name = "Шайтан"
	fmt.Printf("Value %v, type %T\n", animal, animal) //Value &{Шайтан}, type *main.Dog - выводит новоиспеченное св-во

	//4) вызов метода интерфейсного типа
	/*
		значение интерфейсного типа != nil, когда конкретный тип (структура) != nil (type <nil>). Мы можем безопасно
		вызвать метод у интерфейса только в случае, когда значение интерфейсного типа != nil (type <nil>). В противном
		случае мы словим панику.
	*/

	var a Animal
	// a.Speak() //паника!
	a = &Dog{} //присвоили
	a.Speak()  //ok

	//5) как go хранит "под капотом" значение интерфейсного типа?
	/*
		когда в go объявляем значение интерфейсного типа:
		var animal Animal

		go создает объект интерфейса (именно в момент объявления значения интерфейсного тирп). Внутри, интерфейс - это
		связка:
		•	указателя на данные, которые интерфейс содержит.
		•	указателя на таблицу методов, соответствующую конкретному типу.
		Для этого Go использует структуру iface (упрощенно) (исходники runtime GO src/runtime/runtime2.go):
		type iface struct {
			tab  *itab
			data unsafe.Pointer
		}
		tab -  это указатель на Interface Table или itable - структуру, которая хранит некоторые метаданные о типе и
		список методов, используемых для удовлетворения интерфейса (указатель на таблицу методов (и тип)).
		data - хранимые данные (указатель на значение)

		itab - это то, что "связывает" интерфейс и конкретный тип:
		type itab struct {
			inter *interfacetype  // описание интерфейса
			_type *_type          // описание реального типа
			hash  uint32
			_     [4]byte         // padding
			fun   [1]uintptr      // таблица методов (vtable)
		}



		РЕАЛЬНЫЙ ПРИМЕР:
		type Animal interface {
			Speak() string
		}

		type Dog struct{}

		func (Dog) Speak() string {
			return "Woof"
		}

		var a Animal = Dog{}

		ВНУТРИ:
		•	создаётся itab, которая говорит: «Dog реализует Animal, вот метод Speak».
		•	создаётся iface:
			•	tab → указывает на itab
			•	data → указывает на значение Dog{}

		- позволяет понимать, как работает приведение типов, вызов методов через интерфейс и почему интерфейсы “дороже”
		по памяти и CPU

	*/

}
