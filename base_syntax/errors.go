package main

import (
	"errors"
	"fmt"
)

func divide(a int, b int) int {
	return a / b
}

func main() {
	/*
		Go ошибки — это значения с типом error, возвращаемые функциями, как и любые другие значения. Для обработки
		ошибок в Go нужно проверять ошибки, которые могут возвращать функции, и решать, существует ли ошибка. В случае
		её наличия необходимо принять меры для защиты данных и сообщить пользователям или операторам о произошедшей
		проблеме.
	*/
	// var input int
	// _, err := fmt.Scan(&input) // fmt.Scan возвращает два параметра, первый — это количество считанных значений, второй
	// // — ошибка
	// if err != nil {
	// 	fmt.Println("Проверьте типы входных параметров.")
	// } else {
	// 	fmt.Println(divide(input, 5)) // Выводим результат, если ошибок нет
	// }

	/*
		создание ошибок
	*/
	//1) errors.New - получает один аргумент — сообщение об ошибке в виде строки, которую вы можете настроить, чтобы
	// предупредить ваших пользователей о том, что пошло не так.

	err := errors.New("my error")
	fmt.Println("", err)

	//2) panic - позволяет сгенерировать ошибку и выйти из программы, получает строку, которая значит сообщение ошибки
	// panic("test_error") //вырубит программу - exit status 2

	//3) defer - позволяет выполнить определенную операцию после выполнения других действий (даже если сработает panic).
	//При этом не важно, где в реальности вызывается эта функция. Если есть panic - все defer отработают, потом уже
	//программа вылетит.

	defer finish() // Отложенный вызов функции finish
	fmt.Println("Programm has been started")
	fmt.Println("Programm is working")

	//если несколько defer, то выполнятся они в обратном порядке определния (3 - 2 - 1), так как эта команда помещает
	//вызов функции в стек LIFO (Last-In, First-Out).
	defer fmt.Println(1)
	defer fmt.Println(2)
	defer fmt.Println(3)

	//defer запоминает значение переменных на момент объявления defer
	h := 5
	defer fmt.Println(h) //5
	h = 7

	panic("last_panic")
}

func finish() {
	fmt.Println("Programm has been finished")
}
