package main

import (
	"fmt"
	"runtime"
	"sync"
	"sync/atomic"
)

func main() {
	fmt.Println("----------------------------------------------------------------------------------------------------------------")

	fmt.Println("correctIncrement")
	correctIncrement()

	fmt.Println("----------------------------------------------------------------------------------------------------------------")

	fmt.Println("useOwnMutex")
	useOwnMutex()

	fmt.Println("----------------------------------------------------------------------------------------------------------------")

}

/*
	1) что такое мьютексы и зачем они нужны
	мьютекс - примитив синхронизации, обеспечивающий взаимное исключение исполнения критических участков кода.
	В критической секции может быть только одна горутина.

	type Mutex struct {...}

	захватить мьютекс 			  - func (m *Mutex) Lock()
	освободить мьютекс 			  - func (m *Mutex) Unlock()
	попробовать захватить мьютекс - func (m *Mutex) TryLock() bool
*/

func correctIncrement() {
	mutex := sync.Mutex{}
	wg := sync.WaitGroup{}
	wg.Add(1000)
	value := 0
	for i := 0; i < 1000; i++ {
		go func() {
			defer wg.Done()

			mutex.Lock()
			value++ //критическая секция, в ней может находиться только одна горутина
			mutex.Unlock()
		}()
	}

	wg.Wait()
	fmt.Println(value)
}

//----------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------

/*
	Состояние горутин:
	1) running (исполняет код)
	2) ready (готова к исполнению)
	3) waiting (ждет чего-то, например пока освободится захваченный мьютекс)

	Когда горутина блокируется на мьютексе (пытается захватить, а он захвачен) - она переходит из Running в Waiting.

*/

//----------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------

//Написать свои собственные мьютексы
/*
	гарантии:
	1) взаимоисключение (safety) - между парными вызовами mutex.Lock() и mutex.Unlock() может находиться только одна
	горутина
	2) прогресс (liveness) - если одна или несколько горутин пытаются захватить мьютекс, то только один из вызовов
	mutex.Lock() должен завершиться успешно (горутины не должны бесконечно мешать друг другу)
*/

const (
	unlocked = false
	locked   = true
)

type OwnMutex struct {
	state atomic.Bool
}

const retriesNumber = 3

func (m *OwnMutex) Lock() {
	retries := retriesNumber
	for !m.state.CompareAndSwap(unlocked, locked) { //CAS (атомарная операция)
		/*
			чаще всего бывает разумнее отдавать управление не сразу, а немного покрутиться в цикле, так как крит секции
			обычно делают короткие
		*/
		retries--
		if retries == 0 {
			runtime.Gosched() //уступает поток другой горутине
			retries = retriesNumber
		}
	}
}

func (m *OwnMutex) Unlock() {
	m.state.Store(unlocked)
}

func useOwnMutex() {
	var mutex OwnMutex
	wg := sync.WaitGroup{}
	wg.Add(1000)

	value := 0
	for i := 0; i < 1000; i++ {
		go func() {
			defer wg.Done()

			mutex.Lock()
			value++
			mutex.Unlock()
		}()
	}

	wg.Wait()

	fmt.Println(value)
}

/*

	Спинлок (spinlock) в Go — это вид блокировки, при котором горотина активно ждёт (крутится в цикле)
	освобождения ресурса, не отдавая управление планировщику (в отличие от sync.Mutex, где поток может
	быть “усыплён”).

	while isLock {
		//крутимся до тех пор, пока какая-нибудь горутина не отпустит спинлок (spin lock).
	}

	Что делать если лок слишком большой? Как избавиться от этого спинлока?
	1) sleep (но сколько спать непонятно)
	2) pause (spin loop hint)
	- подразумевает что
*/

//Мьютекс рантайма GO
/*

	type Mutex struct {
		state int32
		sema int32
	}

	state:
	- каждый бит означает свое состояние:
	0 - выставляется в 1, если мьютекс заблокирован в данный момент
	1 - выставляется в 1, если какая-либо горутина была разбужена и пытается получить мьютекс
	2 - выставляется в 1, если мьютекс находится в режиме "starvation" (голод)
	3-31 - остальные биты отслеживают, сколько горутин ожидают мьютекса


	sema:
	-
*/

/*
	Мьютексы в рантайме Go не хранят у себя владельца блокировки (ID потока, который захватил мьютекс),
	поэтому можно снять блокировку другой горутиной. То есть GO не проверяет, кто именно заблокировал
	мьютекс и теперь вызывает unlock! К примеру, в ядре линкуса тоже есть мьютексы, и они хранят владельца.

	var mu sync.Mutex

	go func() {
		mu.Lock()
		// ...
	}()

	go func() {
		mu.Unlock() // ❗Это сработает, даже если Lock делала другая горутина
	}()

	- это нужно знать. Ошибиться можно только если неправильно пользоваться мьютексом.
*/

/*
	У мьютекса нет очереди/листа заблокированных горутин. Где они тогда хранятся?
	Есть Global pool, где хранятся адреса мьютексов. К каждому адресу мьютекса привязывается очередь ожидания. Когда
	происходит освобождение мьютекса - идет в global pool, ищет его очередь (в рантайме линукс, к примеру, у каждого
	мьютекса хранится своя очередь).

	┌────────────────────┐
	│ mutex address #1   │ ─────▶    wait_list P1 ──► P6 ──► P2
	└────────────────────┘

	┌────────────────────┐
	│ mutex address #2   │ ─────▶    wait_list P3
	└────────────────────┘

	┌────────────────────┐
	│ mutex address #3   │ ─────▶    wait_list P7 ──► P4
	└────────────────────┘

	В GO используется сбалансированное дерево тех, кто ожидает мьютекс (wait_list в форме дерева хранится).

	Не будут ли горутины голодать в этой очереди?

	NORMAL MODE

	STARVATION MODE

	Мьютексы практически идентичны на разных уровнях абстракций. Мьютексты ядра Linux и мьютексы рантайма GO очень похожи.

*/

/*
	Shared Mutex (RW)
	- примитив синхронизации, который позволяет нескольким горутинам иметь доступ к общему ресурсу для чтения, но блокирует
	доступ для записи только одной горутине (получается, в крит секции могут находиться либо много читателей, либо только
	один писатель). Один писатель и много читателей не могут одновременно находиться в критической секции, потому что это
	может привести к гонке данных (data race), неконсистентному состоянию и логическим ошибкам.

	API:

	type RWMutex struct { ... }

	func (rw *RWMutex) Lock()               // блокировать на запись
	func (rw *RWMutex) RLock()              // блокировать на чтение
	func (rw *RWMutex) RLocker() Locker     // возвращает интерфейс Locker, реализую методы RLock и RUnlock
	func (rw *RWMutex) Unlock()             // разблокировать запись
	func (rw *RWMutex) TryLock() bool       // попробовать заблокировать на запись
	func (rw *RWMutex) TryRLock() bool      // попробовать заблокировать на чтение
	func (rw *RWMutex) RUnlock()            // разблокировать чтение
*/

//Реализация

func useOwnRWMutex() *RWMutex {
	var mutex sync.Mutex
	notifier := sync.NewCond(&mutex)

	return &RWMutex{
		mutex:    &mutex,
		notifier: notifier,
	}
}

type RWMutex struct {
	notifier      *sync.Cond  //примитив синхронизации, позволяющий разбудить и усыпить
	mutex         *sync.Mutex //стандартный мьютекс
	readersNumber int
	hasWriter     bool
}

func (m *RWMutex) Lock() {
	m.mutex.Lock()
	defer m.mutex.Unlock() //при выходе отпускаем его

	for m.hasWriter { //если есть писатель - засыпаем и разблокируем мьютекс
		m.notifier.Wait() //ждем пока не выйдет какой-то писатель, так как в крит секции может быть один писатель
	}

	m.hasWriter = true         //мы вышли, значит писатель вышел, мы становимся писателем
	for m.readersNumber != 0 { //жду пока все читатели не выйдут отсюда, так как в критической секции может находиться либо много писателей, либо только ОДИН читатель
		m.notifier.Wait()
	}
	m.notifier.Wait()
}

func (m *RWMutex) Unlock() {
	m.mutex.Lock()
	defer m.mutex.Unlock()

	m.hasWriter = false    //я уже не писатель
	m.notifier.Broadcast() //все, кто был на Wait(), проснутся
}

// блокировка чтения
func (m *RWMutex) RLock() {
	m.mutex.Lock()
	defer m.mutex.Unlock()

	for m.hasWriter { //пока есть писатель - зайти не могу
		m.notifier.Wait()
	}

	m.readersNumber++ //увеличиваю количество читателей
}

func (m *RWMutex) RUnlock() {
	m.mutex.Lock()
	defer m.mutex.Unlock()

	m.readersNumber--         //убавляем количество читателей
	if m.readersNumber == 0 { //выходим
		m.notifier.Broadcast() //все, кто был на Wait(), проснутся
	}
}

//...есть много других видов мьютексов (рекурсивные, временные...). Они все тоже расширяют базовый мьютекс.

//https://www.youtube.com/watch?v=h6-Jiohy1Ak&ab_channel=%D0%92%D0%BB%D0%B0%D0%B4%D0%B8%D0%BC%D0%B8%D1%80%D0%91%D0%B0%D0%BB%D1%83%D0%BD
