package main

import (
	"context"
	"fmt"
	"time"
)

func main() {
	//УТЕЧКА ГОРУТИН
	/*
		В данном случае - мы должны закончить работу через 1 миллисекунду (контекст Done). Но, так как
		мы НЕ остановили горутину, записывающую значения в канал - она продолжит крутиться. Это и есть
		утечка горутины. Она будет пытаться писать в канал значения, но так как их уже никто не читает,
		а у канала нет буфера - она зависает на операции **ch <- i** и остается висеть в памяти. Дедлока
		не будет, так как он происходит только если в программе больше нечему работать, но в нашем случае
		могут быть другие работающие функции и тд.
		Решение: перестать писать в канал если контекст завершился.
	*/

	leakF := func() {
		ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond)
		defer cancel()

		ch := make(chan int)
		go func() {
			for i := range 1000 {
				ch <- i
				//ПРЕДОТВРАЩЕНИЕ УТЕЧКИ ГОРУТИНЫ:
				// select {
				// case ch <- i:
				// case <-ctx.Done():
				// }
			}
			close(ch)
		}()

		for {
			select {
			case v, ok := <-ch:
				if !ok {
					return
				}
				fmt.Println(v)
			case <-ctx.Done():
				return
			}
		}
	}

	leakF()
}
