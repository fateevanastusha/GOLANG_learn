package main

import (
	"bufio"
	"fmt"
	"os"
	"sync"
)

func main() {
	generatorUser_1()
	generatorUser_2()
}

func generatorUser_1() {
	/*
		 	generator
			есть функция, создающая канал, заполняющая его и возвращающая этот канал только на чтение
			- между созданием канала и между возвратом канала нет блокирующих действий
	*/
	fmt.Println("generator\n")
	ch1 := generator_1()

	for range 10 { //ЗАКРЫВАТЬ КАНАЛ НЕ ОБЯЗАТЕЛЬНО
		fmt.Println("ch1 = ", <-ch1)
	}

	fmt.Println("--")

	ch2 := generator_2()
	for v := range ch2 { //ЗАКРЫВАТЬ КАНАЛ ОБЯЗАТЕЛЬНО
		fmt.Println("ch2 = ", v)
	}
}

func generator_1() <-chan int {
	ch := make(chan int)
	go func() {
		for i := range 10 {
			ch <- i + 1 //генерация данных
		}
		close(ch) //закрытие канала нужно только в том случае, если я читаю его через range
	}()

	return ch //автоматически преобразуется в канал только на чтение
}

// несколько писателей
func generator_2() <-chan int {
	ch := make(chan int)
	wg := &sync.WaitGroup{}

	wg.Add(2)
	go func() {
		for i := range 10 {
			ch <- i + 1 //генерация данных
		}
		defer wg.Done()
	}()

	go func() {
		for i := range 10 {
			ch <- i + 10 //генерация данных
		}
		defer wg.Done()
	}()

	go func() {
		wg.Wait()
		close(ch)

	}()

	return ch //автоматически преобразуется в канал только на чтение
}

func generatorUser_2() {

	/*
		генератор - как фонтан, который непрерывно производит значения, которые мы можем использовать при необходимости.
		В Go это функция, которая создает поток значений и отправляет их по каналу, позволяя другим частям нашей программы
		получать эти значения по запросу.
	*/

	/*
		1) Создает канал для отправки значений
		2) Запускает горутину для генерации значений
		3) Немедленно возвращает канал для использования потребителями
	*/

	// Создаем генератор который генерит числа 1-5
	numbers := generateNumbers(5)

	// Получаем числа
	for num := range numbers {
		fmt.Println("Received NUMBER:", num)
	}

	fmt.Println("----------------------------------------------------------------------------------------------")

	// Создаем генератор который читает файл построчно
	lines := generateLines("text.txt")

	// Получаем числа
	for line := range lines {
		fmt.Println("Received LINE:", line)
	}

	/*
		Зачем горутина в этом случае?
		Если не использовать горутину - то мы будем дожидаться генерации ВСЕХ значений, если возникнет ошибка, то мы вообще не получим
		ни одного значения, когда как в случае с горутиной мы получаем их по мере поступления.

		1) Неблокирующее выполнение — Генерация и обработка происходят одновременно, что позволяет эффективно использовать
		ресурсы и не ждать полной загрузки данных.
		2) Эффективное использование памяти — Данные генерируются и обрабатываются по одному значению, что снижает потребление памяти,
		так как нет необходимости хранить весь массив.
		3) Поддержка бесконечных последовательностей — Можно генерировать бесконечные последовательности (например, числа Фибоначчи)
		без проблем с памятью.
		4) Автоматическая обработка «Backpressure» — Если потребитель обрабатывает данные медленнее, генератор естественно замедляется
		из‑за блокировки канала, что предотвращает перегрузку памяти.

		мере поступления.
	*/

	// generateNumbersWithoutGoroutine := func(max int) []int {
	// 	numbers := make([]int, max)
	// 	for i := 1; i <= max; i++ {
	// 		numbers[i-1] = i
	// 		// Тяжелые вычисления тут
	// 		time.Sleep(100 * time.Millisecond)
	// 	}
	// 	return numbers
	// }

}

func generateNumbers(max int) chan int {
	// Создаем канал для отправки сообщений
	out := make(chan int)

	// Запускаем горутину для генерации чисел
	go func() {
		// ВАЖНО: всегда закрываем канал после завершения
		defer close(out)

		for i := 1; i <= max; i++ {
			out <- i // Кладем значение в канал
		}
	}()

	// Возвращаем канал
	return out
}

func generateLines(filename string) chan string {
	out := make(chan string)
	go func() {
		defer close(out)
		file, err := os.Open(filename)
		if err != nil {
			return
		}
		defer file.Close()

		scanner := bufio.NewScanner(file)
		for scanner.Scan() {
			out <- scanner.Text()
		}
	}()
	return out
}
