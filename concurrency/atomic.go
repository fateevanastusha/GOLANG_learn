package main

import (
	"fmt"
	"log"
	"runtime"
	"sync"
	"sync/atomic"
	"time"
)

/*
Атомики - это один из методов синхронизации горутин. Наряду с mutex является примитивом синронизации
низкого уровня. Атомики являются "low-level atomic memory primitives", реализуют атомарные операции
с памятью. На основе атомиков построен пакет sync.

“Атомики” (или атомарные операции, атомарные переменные) — это способ безопасной работы с памятью и
переменными в многопоточном окружении. Они нужны, чтобы предотвратить гонки данных (data races) при
доступе к разделяемым данным из нескольких потоков без использования тяжёлых примитивов синхронизации,
таких как мьютексы.

Атомарная операция — это операция, которая либо полностью завершается, либо не происходит вовсе, и никакой
другой поток не может увидеть “промежуточное” состояние.

int counter = 0;
counter++;

Инкремент распадается на:
	1.	Загрузка значения (load)
	2.	Инкремент
	3.	Запись обратно (store)

Если два потока одновременно выполняют counter++, возможна ситуация, где инкремент “теряется” (то есть две
горутины одновременно прочитают одно и то же значение, и запишут одно и то же значение).

Зачем нужны атомики?
	1.	Обеспечение корректности данных при одновременном доступе из нескольких потоков.
	2.	Повышение производительности по сравнению с мьютексами:
	•	Нет блокировок.
	•	Нет переключения контекста.
	•	Нет лишних системных вызовов.
	3.	Используются в низкоуровневых структурах данных, лок-фри/вейт-фри алгоритмах, реализации мьютексов/спинлоков,
	пулов потоков, lockless очередях и стэках, счетчиках ссылок (reference counters) и т.д.

Он работает с типами (с каждым отдельно), потому что тогда еще не было дженериков и приходилось делать
отдельный метод под каждый тип.
T: INT32, INT64, UINT32, UINT64, UINTPTR
Для каждого типа предусмотрены методы:
1) AddT
2) LoadT
3) StoreT
4) SwapT
5) CompareAndSwapT
6) atomic.Value
*/

//-------------------------------------------------------------------------------------------------------------------------------

//1) ADD_T
/*
	- инкрементирует значение
	- принимает указатель на переменную и значение, которое нужно прибавить
*/
func add() {
	start := time.Now()
	var (
		counter int64
		wg      sync.WaitGroup
	)

	wg.Add(1000)

	for i := 0; i < 1000; i++ {
		go func() {
			defer wg.Done()
			/*
				Безопасно даже при одновременном доступе из многих горутин, исключает data race. При запуске через
				"go run -race main.go" можно убедиться, что data race нет.
			*/
			atomic.AddInt64(&counter, 1) //сработает в 10 раз быстрее Mutex, потому что работает на уровне процессора (для каждой OS своя реализация)
		}()
	}
	wg.Wait()
	fmt.Println(counter)
	fmt.Println("With atomic:", time.Now().Sub(start).Seconds())
}

//2) STORE_T, LOAD_T, SWAP_T
/*
	store:
		- позволяет атомарно положить значение в какую-то переменую
		- принимает указатель на переменную
	load:
		- позволяет атомарно получить значение
		- принимает указатель на переменную
	swap:
		- позволяет положить новое значение и достать предыдущее (возвращает предыдущее)
		- принимает указатель на переменную и новое значение
*/

func store_load_swap() {

	var counter int64

	fmt.Println("after load - ", atomic.LoadInt64(&counter)) //0

	atomic.StoreInt64(&counter, 5)
	fmt.Println("after store - ", atomic.LoadInt64(&counter)) //5

	fmt.Println("after swap, previous value - ", atomic.SwapInt64(&counter, 10))
	fmt.Println("after swap, current value - ", atomic.LoadInt64(&counter))
}

//3) COMPAREANDSWAP (CAS)
/*
	- позволяет атомарно положить значение в какую-то переменую, но при этом мы должны указать старое значение, и,
	если они совпадают, он установит новое значение. Возвращает bool, если удалось изменить значение - true, в ином
	случае - false
	- принимает указатель на переменную, старое требуемое значение, новое значение
*/

func compareAndSwap() {
	var (
		counter int64
		wg      sync.WaitGroup
	)
	wg.Add(100)

	for i := 0; i < 100; i++ {
		go func(i int) {
			defer wg.Done()

			if !atomic.CompareAndSwapInt64(&counter, 0, 1) {
				return
			}

			fmt.Println("Swapped goroutine number is", i) //свапнет ТОЛЬКО ОДНУ горутину, так как 0 будет только один раз
		}(i)
	}

	wg.Wait()
	fmt.Println(counter)
}

//3) VALUE
/*
	- можно вызвать у структуры все вышеупомянутые методы
*/

func atomicVal() {
	var (
		value atomic.Value //тип - пустой интерфейс
	)
	fmt.Println("value after load -", value.Load())

	value.Store(1)
	fmt.Println("value after store -", value.Load())

	value.Swap(2)
	fmt.Println("value after swap -", value.Load())
	value.CompareAndSwap(2, 3)
	fmt.Println("value after compareandswap -", value.Load())
}

/*
	Барьеры памяти

	В рамках одного потока компилятор может переставлять инструкции в любом порядке, если это не
	нарушает обозреваемого пути исполнения (то есть логики, то есть независимые операции он может
	поменять местами).

	first := 10
	second := 20
	third := 0
	first ++					//независимые, переставить местами можно
	second ++					//независимые, переставить местами можно
	third ++					//независимые, переставить местами можно
	third = first + second		//зависит от 1 и 2, переставить нельзя

	Процессор (более низкоуровневая сущность) тоже может менять код как ему заблагорассудится, с тем
	же самым условием, что и компилятор.



	При работе с памятью есть только две операции:
	1) load - читать
	2) write - писать
	это приводит к 4 комбинациям того, что мы не хотим переупорядочивать

	Барьер - это по сути стена, которая запрещает передвигать операции до и после себя
	ПОЛНЫЙ БАРЬЕР
	Любая сущность (процесс, компилятор) может менять порядок инструкций в пределах блока "до барьера"
	и в пределах блока "после барьера", если это не нарушает целостности. Но ни одна операция из блока
	"до барьера" не может быть перенесена в блок "после барьера", и наоборот. Между ними стена.

	БАРЬЕР ЗАПИСИ (WriteWrite)
	- операции записи НЕ могут перемещаться (прыгать вниз барьера или вверх), но операции чтения МОГУТ
	- все операции записи до барьера будут выполнены до всех операций записи после барьера
	БАРЬЕР ЧТЕНИЯ (LoadLoad)
	- операции чтения НЕ могут перемещаться (прыгать вниз барьера или вверх), но операции записи МОГУТ
	- все операции чтения до барьера будут выполнены до всех операций чтения после барьера (я могу между
	этими типами операций поставить барьер, до этой стены операции все будут выполнены ДО всех операций
	после этой стены)
	БАРЬЕР ACQUIRE (LoadLoad + LoadWrite)
	- внутрь барьера могут зайти чтения и записи, но после него никто выйти не может
	БАРЬЕР RELEASE (WriteWrite + LoadWrite)
	- внутрь барьера никто попасть не может, но выйти из него могут операции и чтения, и записи

	* - в каких-то ситуациях можно использовать вместо full барьера барьеры записи или чтения, так как
	это производительнее

	По сути мьютекс Lock Unlock - это барьеры памяти.
	Барьеры памяти влияют ТОЛЬКО НА ПОРЯДОК ИНСТРУКЦИЙ! Они должны гарантировать порядок исполнения инструкций
	относительно памяти (ОЗУ, кэши). Говоря, что они "отменяют" оптимизацию, нужно понимать, что они отменяют
	только оптимизацию, которая пытается изменить порядок инструкций, которые взаимодействуют с памятью. Ни
	на какую другую оптимизацию барьеры памяти не влияют.

*/

var a string
var done atomic.Bool

func setup() {
	//редкий кейс, когда синхронизации атомика не надо
	//тут есть data race, потому что назначение строки и done = true может ПОМЕНЯТЬСЯ местами в компиляторе, и в useSetup он выведет nil вместо этой строки!
	//(до того как атомик добавили)
	a = "hello, world" //нет синхронизации, так как когда используется atomic - используется full barier, значит эта операция не может опуститься под done.Store
	done.Store(true)   //это становится барьером и все, что должно было выполниться ДО - выполнится ДО.
	if done.Load() {
		log.Println(len(a))
	}
}

func useSetup() {
	go setup()

	for !done.Load() {
		runtime.Gosched() //освобождает место для выполнения другой горутины
	}

	log.Println(a)
}

func main() {
	fmt.Println("-------------------------------------------------------------------------------------------------------------------------------")
	fmt.Println("ADD\n")
	add()
	fmt.Println("-------------------------------------------------------------------------------------------------------------------------------")
	fmt.Println("STORE_LOAD_SWAP\n")
	store_load_swap()
	fmt.Println("-------------------------------------------------------------------------------------------------------------------------------")
	fmt.Println("COMPAREANDSWAP\n")
	compareAndSwap()
	fmt.Println("-------------------------------------------------------------------------------------------------------------------------------")
	fmt.Println("VALUE\n")
	atomicVal()
	fmt.Println("-------------------------------------------------------------------------------------------------------------------------------")
	fmt.Println("SETUP\n")
	useSetup()
}

//https://habr.com/ru/articles/744822/
