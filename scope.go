package main

import (
	"fmt"
)

/*
	Когда переменная объявляется, она попадает в область видимости. Проще говоря, переменная
	становится видимой.

	1) В Go область видимости начинает и заканчивается фигурными скобками {} (кроме case и default
	в switch, там фигурные скобки не нужны - это единственный случай).



	2) Имя, объявленное внутри синтаксического блока, невидимо вне этого блока.

	func scope() {
		v := 1
		fmt.Print(v) // 1
	}

	func main() {

		* Если мы не будем рассматривать вопрос времени жизни переменной,
		* а сконцентрируемся только на области видимости, то можем сказать,
		* что из функции main мы не можем получить доступ к переменной v,
		* объявленной в функции scope.

		scope()
		fmt.Print(v) // Ошибка компиляции: переменная v не существует в main
	}



	3) Блоки:
	- можно объявить несколько переменных с одинаковыми именами, если эти переменные находятся
	в разных лексических блоках.
	- компилятор, сталкиваясь с ссылкой на переменную, будет искать соответствующее
	объявление, начиная с самого вложенного блока и продолжая до самых внешних (спускается
	"вниз", но "вверх" он НИКОГДА не поднимается).
	- если переменная не найдена, компилятор выдает ошибку «необъявленное имя».
	- если переменная объявлена как внутри, так и снаружи, то внутреннее приоритетнее (то
	есть он при спуске "вниз" возьмет первое, что найдет).

*/

func ExampleScope1() {
	var v int = 1

	{
		/*
		 * Здесь переменная v из внешнего блока затеняется переменной v
		 * из внутреннего блока.
		 */
		var v string = "2"
		fmt.Println(v) // 2
	}

	fmt.Println(v) // 1

	/*
	 * В этом примере мы объявили переменные с одинаковыми именами, но с разными типами
	 * в разных лексических блоках. Результат вывода будет зависеть от того, в каком блоке
	 * происходит обращение к переменной.
	 */

	// Output:
	// 2
	// 1

	fmt.Println("-----------------------------------------------------------------------")

}

func ExampleScope2() {
	var i string = "Строка"

	/*
	 * Переменная i объявляется вне фигурных скобок, но в теле цикла
	 * происходит затенение переменной i, поскольку она объявляется заново.
	 */
	for i := 0; i < 1; i++ {
		fmt.Println(i) // 0
	}

	/*
	 * Во втором цикле переменная i из внешнего блока снова затеняется
	 * переменной i внутри тела цикла.
	 */
	for i := 0; i < 1; i++ {
		i := true
		fmt.Println(i) // true
	}

	fmt.Println(i) // Строка

	// Output:
	// 0
	// true
	// Строка

	fmt.Println("-----------------------------------------------------------------------")

}

/*
	4) при кратком объявлении переменной в блоках if, switch, for - за пределами этих блоков
	переменная уже не доступна.

	for count := 10; count > 0; count-- {
		fmt.Println(count) //доступна
	} // count больше не в области видимости

	if num := rand.Intn(3); num == 0 {
		fmt.Println("Space Adventures")
	} else if num == 1 {
		fmt.Println("SpaceX")
	} else {
		fmt.Println("Virgin Galactic")
	} // num больше не в области видимости

	switch num := rand.Intn(10); num {
	case 0:
		test := "test" // у каждого case есть СВОЯ собственная область видимости
		fmt.Println("Space Adventures")
	case 1:
		fmt.Println("SpaceX")
	case 2:
		fmt.Println("Virgin Galactic")
	default:
		fmt.Println("Random spaceline #", num)
	}
*/

func main() {
	ExampleEnvironment()
	ExampleClosure()
}

/*
	5) область видимости анонимной функции
	анонимная имеет доступ к окружению, в котором она была объявлена. Когда анонимная функция
	использует переменные, объявленные за ее рамками, ее называют замыканием.
*/

func externalFunction() func() {
	text := "TEXT"

	return func() {
		fmt.Println(text)
	}
}

func ExampleEnvironment() {
	fn := externalFunction()
	fn()

	// Output:
	// TEXT
}

/*

 */

func ExampleClosure() {
	fn := func() func(int) int {
		count := 0
		return func(i int) int {
			count++
			return count * i
		}
	}()

	for i := 1; i <= 5; i++ {
		fmt.Println(fn(i))
	}

	// Output:
	// 1
	// 4
	// 9
	// 16
	// 25
}
