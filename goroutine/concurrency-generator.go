package main

import (
	"bufio"
	"fmt"
	"os"
)

func generateNumbers(max int) chan int {
	// Создаем канал для отправки сообщений
	out := make(chan int)

	// Запускаем горутину для генерации чисел
	go func() {
		// ВАЖНО: всегда закрываем канал после завершения
		defer close(out)

		for i := 1; i <= max; i++ {
			out <- i // Кладем значение в канал
		}
	}()

	// Возвращаем канал
	return out
}

func generateLines(filename string) chan string {
	out := make(chan string)
	go func() {
		defer close(out)
		file, err := os.Open(filename)
		if err != nil {
			return
		}
		defer file.Close()

		scanner := bufio.NewScanner(file)
		for scanner.Scan() {
			out <- scanner.Text()
		}
	}()
	return out
}

func main() {
	/*
		генератор - как фонтан, который непрерывно производит значения, которые мы можем использовать при необходимости.
		В Go это функция, которая создает поток значений и отправляет их по каналу, позволяя другим частям нашей программы
		получать эти значения по запросу.
	*/

	/*
		1) Создает канал для отправки значений
		2) Запускает горутину для генерации значений
		3) Немедленно возвращает канал для использования потребителями
	*/

	// Создаем генератор который генерит числа 1-5
	numbers := generateNumbers(5)

	// Получаем числа
	for num := range numbers {
		fmt.Println("Received NUMBER:", num)
	}

	fmt.Println("----------------------------------------------------------------------------------------------")

	// Создаем генератор который читает файл построчно
	lines := generateLines("text.txt")

	// Получаем числа
	for line := range lines {
		fmt.Println("Received LINE:", line)
	}

	/*
		Зачем горутина в этом случае?
		Если не использовать горутину - то мы будем дожидаться генерации ВСЕХ значений, если возникнет ошибка, то мы вообще не получим
		ни одного значения, когда как в случае с горутиной мы получаем их по мере поступления.

		1) Неблокирующее выполнение — Генерация и обработка происходят одновременно, что позволяет эффективно использовать
		ресурсы и не ждать полной загрузки данных.
		2) Эффективное использование памяти — Данные генерируются и обрабатываются по одному значению, что снижает потребление памяти,
		так как нет необходимости хранить весь массив.
		3) Поддержка бесконечных последовательностей — Можно генерировать бесконечные последовательности (например, числа Фибоначчи)
		без проблем с памятью.
		4) Автоматическая обработка «Backpressure» — Если потребитель обрабатывает данные медленнее, генератор естественно замедляется
		из‑за блокировки канала, что предотвращает перегрузку памяти.

		мере поступления.
	*/

	// generateNumbersWithoutGoroutine := func(max int) []int {
	// 	numbers := make([]int, max)
	// 	for i := 1; i <= max; i++ {
	// 		numbers[i-1] = i
	// 		// Тяжелые вычисления тут
	// 		time.Sleep(100 * time.Millisecond)
	// 	}
	// 	return numbers
	// }

}
