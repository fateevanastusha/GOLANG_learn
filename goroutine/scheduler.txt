КОМПЬЮТЕР (OS)

Процессор может выполнять ОДНОВРЕМЕННО несколько действий, только если у него несколько ядер.
Но при этом даже если ядро одно - он может выполнять несколько задач, переключаясь между ними
так быстро, что нам кажется, что они выполняются одновременно (но в один момент времени при этом
выполняется один процесс).



Конкурентность (Concurrency) - это дизайн программы. Когда у нас есть несколько процессов, которые
могут выполняться независимо друг от друга, не важно в каком порядке (когда мы работаем со множеством
вещей одновременно).
Параллельность (Parallelism) — это уже про выполнение программы, а именно — выполнение нескольких задач
в один момент времени (когда выполняем множество вещей одновременно).



Поток (тред) - это последовательность команд, которые выполняются в рамках одного процесса (это та работа,
которая выполняется на процессоре, либо ждёт своей очереди). У треда три состояния:
    1) Executing: выполняется прямо сейчас на одном из ядер
    2) Runnable: готов к выполнению, дожидается своей очереди
    3) Waiting: не готов к выполнению, так как ждёт какого-то события. Например, это может быть связано с i/o
    операцией, взаимодействием с ОС (syscall) и др.



Переключение контекста (context switching) - планировщик ОС может в любой момент времени переключать треды
(отключать выполняющиеся от ядра процессора и заменять ил Runnable тредами). Этот подход называется
вытесняющей многозадачностью (preemptive multitasking).
1) переключение контекста занимает много времени (нужно обновить данные в кэшах процессора, сохранить состояние
треда и др.). Чем больше у нас тредов в состоянии Runnable, тем чаще будет переключаться контекст, и тем медленнее
будет работать программа. К примеру, если переключений слишком много, то всем они суммарно могут занимать столько
же времени, сколько само выполнение задач (а то и больше).
2) занимает много памяти - стек каждого треда часто может занимать до пары мегабайт (в нём хранятся локальные
переменные, цепочки вызова функций и др.).
У тредов дорого и создание, и удаление, и само существование.

KERNEL SPACE - пространство ядра
USER SPACE - пространство пользователя
Планирование потоков на уровне kernel space, то есть ими управляет ОС



ПЛАНИРОВЩИК GO

Планировщик - управляет горутинами.

Горутина - аналог треда (потока), но не на уровне ОС, а внутри GO (внутри программы), при этом более
легковесный. Планирование горутин происходит на уровне user space, то есть ими управляет планировщик
GO (Go Runtime). По сути они нужны чтобы более эффективно использовать ресурсы системных потоков. Они
работают эффективнее потому что - переключение между ними дешево (без участия ОС), у них общий доступ
к памяти.

У горутины есть три состояния:
1) Waiting — горутина не готова к запуску, так как чего-то ждёт
2) Runnable — готова к запуску, как только освободится тред
3) Executing — выполняется на каком-то треде

Машина для выполнения (M, Machine) — будет непосредственно выполнять горутину (это системный поток).
Процессор (P, Processor) — будет помещать горутины (G) в Машину (то есть просто привязывать к потоку).

Go приложение имеет размер пула потоков (количество потоков), на котором он работает:
РАЗМЕР ПУЛА = КОЛИЧЕСТВО ДОСТУПНЫХ ЯДЕР (ещё больше тредов нет смысла, ведь тогда часть из них точно
будет простаивать в ожидании свободного ядра, меньше - ядра будут простаивать).
runtime.GOMAXPROCS() задает размер пула (получить текущее - n := runtime.GOMAXPROCS(0)).



ЭЛЕМЕНТЫ МЕХАНИЗМА ПЛАНИРОВЩИКА

1) GRQ (GLOBAL RUN QUEUE)
- глобальная очередь, куда попадают горутины в состоянии Runnable.

2) КАЖДЫЙ ПОТОК:
- приставлен свой собственный процессор, он постоянно ищет задачи и передает их в поток. Если в его локальной
очереди задач нет - ворует их у других процессоров, либо берет из GRQ, либо из NETPOLLER.
- есть LRQ (local run queue) - тут лежат горутины в состоянии Runnable. LRQ нужна для того, чтобы избавиться
от блокировок. Если бы у всех процессоров была одна очередь - им пришлось бы ее блокировать, чтобы взять
оттуда задачу (чтобы одну и ту же не взяли сразу два процессора), из-за этого это бы работало очень медленно.
- сам поток - там находится горутина в состоянии Running.

3) HANDOFF
горутина может вызвать какую-то блокирующую долгую операцию (syscall - системный вызов). Если этот системный
вызов не может работать асинхронно (если может - отправится в NETPOLLER) - тогда заблокируется горутина, процессор
и сам системный тред. Вступает в силу handoff - он отвязывает тред от процессора, создает другой и привязывает
его к процессору. Когда системный вызов закончил свою работу - он либо возвращает горутину тому процессору, от
которого он его отвязал (если тот свободен), либо другому процессору (если нашел свободный), в ином случае
отправляет в GRQ.

4) SYSMON
- механизм оптимизации при syscall, чтобы не создавать втупую каждый раз новый поток при любом синхронном системном
вызове. Сам по себе занимает целый поток, постоянно выполняется фоном. В его обязанности входит оптимизация:
    - если мы знаем, что системный вызов надолго заболкирует тред, то сразу выполним handoff.
    - в иных случаях позволим треду оставаться в заблокированном состоянии, мониторя, не освободился ли
    он. Если он превысит таймаут в 10 ms, то мы запускаем handoff.
    - устанавливает горутине флаг, что она работает слишком долго, чтобы та прервалась.
    - мониторит каждые 10 секунд NETPOLLER, если в него никто не заглядывал более 10ms - то отправляет его горутины
    в состоянии Runnable в GRQ.

5) NETPOLLER (network poller)
- ОС предоставляет механизмы для выполнения асинхронных системных вызовов, с помощью которых можно обойти блокировку
при системном вызове - epoll (Linux), kqueue (MacOS, BSD), IOCP (Windows). Эти механизмы позволяют сделать так:
    1) Тред инициирует системный вызов и идёт по другим своим делам. Системный вызов будет зарегистрирован в
    специальной системе, и мы сможем вернуться к нему позже.
    2) Периодически проверяем, не пришел ли ответ для системного вызова.
НЕ ВСЕ SYSCALL МОГУТ ВЫПОЛНЯТЬСЯ АСИНХРОННО.
В network poller регистрируются те системные вызовы, которые могут выполняться асинхронно. Горутина переводится
в состояние Waiting и передается сюда. Процессор освобождается для выполнения других горутин.

Для I/O операций с сетью можно смело использовать горутины — они будут эффективно обрабатываться через netpoller
(тут тоже есть свои ограничения, но другие).
// Это будет работать через netpoller
conn, _ := net.Dial("tcp", "example.com:80")
data, _ := conn.Read(buf)

Для операций с файлами нужно быть намного аккуратнее, так как они будут блокировать треды.
// А это заблокирует тред
file, _ := os.Open("bigfile.dat") data, _ := file.Read(buf)

Когда горутины дождались своих syscall, они все еще сидят тут в состоянии Runnable и ждут пока их заберут либо
сами процессоры, либо если никто сюда не обращался более 10ms (Sysmon мониторит это в фоне), то освободившиеся
горутины будут отправлены в GRPQ.



АЛГОРИТМ ПОИСКА ЗАДАЧ ПРОЦЕССОРОМ

1) 1/61 раз проверяем GRQ, и если там есть горутины, то берём оттуда.
- GRQ стоит проверять, чтобы горутины там не застаивались.
- 1/61 - потому что это простое число и и это помогает избежать синхронизации проверок между разными P, распределяя
их более равномерно. Еще - это число не слишком большое и не слишком маленькое, поэтому проверки будут не слишком
частыми и не слишком редкими.

2) Если нет, проверяем LRQ
- проверяем свою локальную очередь

3) Если там нет, пытаемся украсть у другого Процессора
- чтобы задачи не застаивались у одного процессора, когда второй полностью свободен. При этом забирает он не одну
задачу, а сразу половину (чтобы потом не пришлось ходить еще раз).

4) Если не получилось, проверяем GRQ
- в итоге задачи нигде не нашлись, просто берем их из GRQ

5) Проверяем Network Poller
- ищет у него горутины в состоянии Runnable, чтобы забрать их в работу. Это как раз те горутины, которые дождались
своих syscall. При этом может быть проблема, что у процессоров работы хватает и они вообще никогда не дойдут до
этого шага, поэтому Sysmon в фоне мониторит - если никто сюда не обращался более 10ms, то освободившиеся горутины
полетят в GRPQ.



ВЫТЕСНЕНИЕ ГОРУТИН

Так как бывают долгоживущие или вечные горутины - предоставлять им процессорное время навсегда -
плохая идея. Так мы не доберемся до других горутин никогда и заблокируем поток. Поэтому есть механизм
остановки горутины. Существует два способа вытеснения горутин:

1) ОСНОВНОЙ СПОСОБ - через проверку stackguard в безопасных точках. Горутина сама решает когда остановиться:

    1) когда горутина проверяет, нужно ли ей остановиться?
    Она выполняет эти проверки в безопасные моменты для вытеснения:
        1) Перед вызовом функций (пролог): Когда функция вызывается, создаётся фрейм стека (выделенная область
        в памяти, где хранятся локальные переменные, адрес возврата и другие данные функции). При прерывании в
        момент вызова функции вся нужная информация уже сохранена во фрейме, поэтому горутину можно приостановить
        без риска потерять данные. При возобновлении выполнения горутина начнёт с этого вызова функции, используя
        те же значения переменных.
        2) При совершении блокирующих операций (наши любимые syscall'ы, таймеры и прочее): в эти моменты горутина
        всё равно будет ждать и простаивать, поэтому пусть поработает кто-то другой.

    2) как горутина понимает, что нужно остановиться?
    Чтобы горутине понять, что ей пора уступить - существует флаг stackguard. Когда нужно прервать горутину,
    этому флагу можно установить значение stackPreempt

    3) кто будет сообщать горутине, что ей нужно остановиться?
    SYSMON будет устанавливать горутине флаг stackguard со значением stackPreempt, если она выполняется больше
    10 ms.



2) ЗАПАСНОЙ СПОСОБ — через сигналы операционной системы, если горутина не хочет останавливаться сама:

    Проблема "жадной горутины", решение этой проблемы в Go v1.14:

    func main() {
        // Устанавливаем количество процессоров = 1
        runtime.GOMAXPROCS(1)

        // запускаем "жадную" горутину, которая захватит процессор
        go func() {
            sum := 0
            for {
                sum++ // бесконечный цикл без вызовов функций
            }
        }()

        // Запускаем time.Sleep, чтобы передать управление жадной горутине
        // и не выйти раньше времени из main()
        time.Sleep(time.Second)
    }

    Горутина заблокировала весь процессор, и не может его отдать. Она не вызывает функции, а значит не проверяет
    stackguard, она не выполняет блокирующие операции, она просто ворует все ресурсы, и наш Sysmon ничего не может
    с этим поделать.

    Поэтому в обновлении 1.14 решили эту проблему:
    если горутина не передает управление больше 10ms добровольно, то ей отправляется сигнал SIGURG и она прерывается
    принудительно.



https://habr.com/ru/articles/891426/