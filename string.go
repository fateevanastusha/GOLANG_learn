package main

import (
	"fmt"
	"strings"
	"unicode"
)

func main() {
	/*
		СТРОКИ
	*/
	/*
		1) строки могут быть созданы через "" (с двойными кавычками) или `` (с обратными апострофами). Разница
		заключается в следующем:
			- "" могут содержать управляющие символы, такие как \n (перенос строки) или \t (символ табуляции).
			- `` (так называемые "raw strings") могут содержать любые символы, включая переводы строк и кавычки,
			и не интерпретируют управляющие последовательности (то есть `NASTYA\nNASTYA` выведет как оно есть -
			NASTYA\nNASTYA, не перенеся строку соответственно).

		2) строки в go - неизменяемые последовательности байтов (НЕ СИМВОЛОВ!):
			- применимы операции, как для массивов и срезов
			- для изменения строки нужно создать новую строку
			- итерируя по строке, вы будете работать с байтами, составляющими строку, а не с символами
			- можно получить подстроку строки

	*/

	// ВЗЯТЬ ПОДСТРОКУ
	// Создадим строковый литерал s, значение которого "Это строка".
	// Строка состоит из 10 символов, но её длина в байтах будет 19, так как кириллические символы занимают 2 байта,
	// а пробел — 1 байт (в UTF-8 один кириллический символ может занимать более одного байта).
	var s string = "Это строка"

	fmt.Printf("Длина строки: %d байт\n", len(s)) //19
	/*
		чтобы получить количество символов, нужно использовать utf8.RuneCountInString():
		utf8.RuneCountInString(s) = 10
	*/

	// Получим подстроку строки
	fmt.Printf("Напечатаем только второе слово в кавычках: \"%v\"\n", s[7:]) //"строка"

	j := "Жаба"
	fmt.Println("Это часть жабы [:1] - ", j[:1]) //�
	/*
		выдаст такой символ, потому что буква Ж занимает 2 байта - и мы по сути ее сломали, взяв только первый байт
		чтобы взять нормально, не сломав строку, используем rune - string(([]rune(j))[:1])
	*/

	// ИЗМЕНИТЬ СТРОКУ
	// Попробуем изменить строку (возникнет ошибка компиляции, так как строки неизменяемы):
	// s[3] = 12
	// Ошибка компиляции: cannot assign to s[3], потому что строки - неизменяемые последовательности.

	// "Изменим строку", создав новую строку
	s = s + " Новая строка"
	fmt.Printf("%v\n", s) //Это строка Новая строка

	// ИТЕРИРОВАТЬСЯ ПО СТРОКЕ
	for _, b := range s {
		fmt.Printf("%v ", b) //числа
	}
	fmt.Print("\n")

	// Output:
	// Длина строки: 19 байт
	// Напечатаем только второе слово в кавычках: "строка"
	// Это строка Новая строка
	// 1069 1090 1086 32 1089 1090 1088 1086 1082 1072 32 1053 1086 1074 1072 1103 32 1089 1090 1088 1086 1082 1072

	fmt.Println("-----------------------------------------------------------------------")

	/*
		3) сравнение строк:
			- можно сравнивать через == и !=
			- можно сравнивать через < и >, но важно помнить, что они сравнивают строки по байтам, а не по символам,
			результат может быть не таким, как ожидалось, если строки содержат символы в разных кодировках
	*/

	// Сравнение строк на равенство
	fmt.Printf("Сравнение на равенство строк \"строка1\" и \"строка2\": %v\n", "строка1" == "строка2") //false

	// Сравнение строк на неравенство
	fmt.Printf("Сравнение на неравенство строк \"строка1\" и \"строка2\": %v\n", "строка1" != "строка2") //true

	// Сравнение строк по алфавиту
	fmt.Printf("\"Строка1\" > \"Строка2\": %v\n", "Строка1" > "Строка2") //false

	// Output:
	// Сравнение на равенство строк "строка1" и "строка2": false
	// Сравнение на неравенство строк "строка1" и "строка2": true
	// "Строка1" > "Строка2": false

	fmt.Println("-----------------------------------------------------------------------")

	/*
		4) функции для работы со строками:
	*/
	fmt.Println(
		// Содержится ли подстрока в строке
		strings.Contains("test", "es"),
		// результат: true

		// Кол-во подстрок в строке
		strings.Count("test", "t"),
		// результат: 2

		// Начинается ли строка с префикса
		strings.HasPrefix("test", "te"),
		// результат: true

		// Заканчивается ли строка суффиксом
		strings.HasSuffix("test", "st"),
		// результат: true

		// Возвращает начальный индекс подстроки в строке, а при отсутствии вхождения возвращает -1
		strings.Index("test", "e"),
		// результат: 1

		// объединяет массив строк через символ
		strings.Join([]string{"hello", "world"}, "-"),
		// результат: "hello-world"

		// Повторяет строку n раз подряд
		strings.Repeat("a", 5),
		// результат: "aaaaa"

		// Функция Replace заменяет любое вхождение old в вашей строке на new
		// Если значение n равно -1, то будут заменены все вхождения.
		// Общий вид: func Replace(s, old, new string, n int) string
		// Пример:
		strings.Replace("blanotblanot", "not", "***", -1),
		// результат: "bla***bla***"

		// Разбивает строку согласно разделителю
		strings.Split("a-b-c-d-e", "-"),
		// результат: []string{"a","b","c","d","e"}

		// Возвращает строку c нижним регистром
		strings.ToLower("TEST"),
		// результат: "test"

		// Возвращает строку c верхним регистром
		strings.ToUpper("test"),
		// результат: "TEST"

		// Возвращает строку с вырезанным набором, каждый символ из "te" считается отдельно
		strings.Trim("tetstet", "te"),
		// результат: s
		strings.Trim("anantsaasfa", "a"),
	)

	fmt.Println("-----------------------------------------------------------------------")

	/*
		5) байтовые срезы ([]byte)
			- это последовательность чисел, где каждый элемент — это байт, то есть значение типа byte (эквивалентно
			uint8)
			- байтовый срез можно изменять (в отличие от строк)
			- к байтовому срезу применимы операции, которые применимы к массивам и срезам других типов: можно брать
			срезы, итерация по элементам и так далее
			- к отдельным байтам применимы операции, как и к обычным числам
			- строки в Go используются гораздо реже, чем байтовые срезы, потому что они неизменяемы, и их основная
			цель — хранить текстовые данные
	*/

	// Используем строку, которую конвертируем в []byte,
	// чтобы показать, как выглядит байтовый срез.
	bs := []byte("Это байтовый срез")

	// Печатаем байтовый срез.
	fmt.Printf("Так байтовый срез выглядит внутри: %v\n", bs) //последовательность чисел

	// Демонстрируем, что байтовый срез можно изменять, а затем выводим его в виде строки.
	for i := range bs {
		// Для чётных байтов увеличиваем на 1, для нечётных уменьшаем на 1.
		if bs[i]%2 == 0 {
			bs[i] = bs[i] + 1
		} else {
			bs[i] = bs[i] - 1
		}
	}

	// Печатаем изменённый байтовый срез в виде строки.
	fmt.Printf("Изменённый байтовый срез в виде строки: %s\n", bs)

	// Output:
	// Так байтовый срез выглядит внутри: [208 173 209 130 208 190 32 208 177 208 176 208 185 209 130 208 190 208
	// 178 209 139 208 185 32 209 129 209 128 208 181 208 183]
	// Изменённый байтовый срез в виде строки: ѬЃѿ!ѰѱѸЃѿѳЊѸ!ЀЁѴѶ

	fmt.Println("-----------------------------------------------------------------------")

	/*
		6) срезы рун ([]rune)
		КОДИРОВКА UNICODE - Это стандарт, который включает все символы всех мировых систем письменности, а также
		различные знаки, такие как символы ударений, диакритические знаки, управляющие коды (например, символы
		табуляции и возврата каретки) и многое другое. Каждому символу в Unicode назначен уникальный номер — код
		символа, или как его называют в Go, руна (rune).
			- тип []rune представляет собой последовательность кодов символов Unicode, где каждый символ соответствует
			одному коду (тип rune в Go эквивалентен int32)

	*/

	// Преобразуем строку в срез рун
	rs := []rune("Это срез рун")

	fmt.Println(rs) //[1069 1090 1086 32 1089 1088 1077 1079 32 1088 1091 1085]

	// Итерируемся по срезу рун и заменяем символ 'р' на '*'
	for i := range rs {
		if rs[i] == 'р' { //р - литерал rune, поэтому можем его сравнить с числом unicode
			rs[i] = '*' //* - литерал rune, поэтому можем его присвоить и оно присвоится как число unicode
		}
	}

	// Выводим изменённый срез в виде строки
	fmt.Printf("Изменённый срез в виде строки: %s\n", string(rs))

	// Output:
	//[1069 1090 1086 32 1089 1088 1077 1079 32 1088 1091 1085]
	// Изменённый срез в виде строки: Это с*ез *ун

	fmt.Println("-----------------------------------------------------------------------")

	/*
		7) UNICODE
	*/

	// функции ниже принимают на вход тип rune, используем литерал, хотя на самом деле он берет число unicode.

	// проверка символа на цифру
	fmt.Println(unicode.IsDigit('1')) // true
	// проверка символа на букву
	fmt.Println(unicode.IsLetter('a')) // true
	// проверка символа на нижний регистр
	fmt.Println(unicode.IsLower('A')) // false
	// проверка символа на верхний регистр
	fmt.Println(unicode.IsUpper('A')) // true
	// проверка символа на пробел
	// пробел это не только ' ', но и:
	//  '\t', '\n', '\v', '\f', '\r' - подробнее читайте в документации
	fmt.Println(unicode.IsSpace('\t')) // true

	// С помощью функции Is можно проверять на кастомный RangeTable:
	// например, проверка на латиницу:
	fmt.Println(unicode.Is(unicode.Latin, 'ы')) // false

	// функции преобразований
	fmt.Println(string(unicode.ToLower('F'))) // f
	fmt.Println(string(unicode.ToUpper('f'))) // F

	fmt.Println("-----------------------------------------------------------------------")

}
