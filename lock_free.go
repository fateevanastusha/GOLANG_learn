package main

import (
	"fmt"
	"sync/atomic"
	"unsafe"
)

/*
	Lock-free
	если мы пишем структуру данных, и если несколько горутин к ней обращается, то мы хотим синхронизировать
	данные, чтобы избежать

	Неблокирующая синхронизация
	- подход в синхронизации, когда не используются блокировки
*/

type item struct {
	value int
	next  unsafe.Pointer
}

type Stack struct {
	head unsafe.Pointer
}

func NewStack() Stack {
	return Stack{}
}

func (s *Stack) Push(value int) {
	node := &item{value: value} //создаем ноду
	for {
		head := atomic.LoadPointer(&s.head)                                    //загрузили предыдущее значение головы
		node.next = head                                                       //ставим предыдущую голову как следующий элемент
		if atomic.CompareAndSwapPointer(&s.head, head, unsafe.Pointer(node)) { //проверяем, что текущая голова равна той, что мы загрузили
			return //если не равна -  то заново крутимся и ловим момент, когда условие пройдеь
		}
	}
}

func (s *Stack) Pop() int {
	for {
		head := atomic.LoadPointer(&s.head) //загрузили текущую голову
		if head == nil {                    //пустой стэк
			return -1
		}
		next := atomic.LoadPointer(&(*item)(head).next)        //атомарно загружаю элемент, который стоит ЗА головой (next)
		if atomic.CompareAndSwapPointer(&s.head, head, next) { //проверяем, что текущая голова равна той, что мы загрузили
			return (*item)(head).value //ставим некст как текущую голову
		}
	}
}

/*
	Какие проблемы могут быть? - в GO никаких. НО:
	ABA проблема
	1) одна горутина выгружает текущую голову в пуше и засыпает
	2) вторая горутина приходит и делает pop, удаляя голову из первого элемента
	3) третья горутина запушила в стэк новый элемент, в ту же ячейку памяти (с тем же адресом памяти)
	- в итоге когда первая горутина сравнивает адреса (они идентичные) - она посчитает что они равны, и CAS вернет true. Но на самом деле там
	уже другие значения, и мы в пуше установим как next УДАЛЕННОЕ значение.

	это невозможно в языках где есть сборщик мусора, так как он не освободит pop-нутую ячейку, на нее все еще будет ссылка из первого пункта.
	Но если это язык с ручным управлением памяти (типа C, C++), то мы можем очистить эту ячейку и произойдет баг.

	РЕШЕНИЕ:
	1) опасные указатели (hazard pointers) - значит, что эту ячейку почистить нельзя.
	2) tagged pointers (48 bit for addressing, but 16 bit unused - делаем счетчик, адреса будут разные и CAS не пройдет).
	3) сборщик мусора (либо для всего приложения, либо только для стэка).
*/

func main() {
	stack := NewStack()
	stack.Push(10)
	stack.Push(20)
	stack.Push(30)

	fmt.Println(stack.Pop()) //30
	fmt.Println(stack.Pop()) //20
	fmt.Println(stack.Pop()) //10
}
