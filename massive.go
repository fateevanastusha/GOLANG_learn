package main

import "fmt"

func main() {

	/*
		Массив — это упорядоченная последовательность элементов одного типа фиксированной длины.
	*/

	//1) обязательно нужно указать длину и тип данных, который будет хранить массив.
	//если при объявлении не определить его значение, то он будет заполнен дефолтными
	//значениями для указанного типа данных
	var a [3]int
	fmt.Println(a) // [0 0 0]

	//массивы разной длины, но с одним типом считаются разными типами, даже если содержат
	//одинаковые данные - [3]int и [5]int — это разные типы

	//можно создать массив нулевой длины
	var tr [0]int   // ok
	fmt.Println(tr) // []

	//задать размер переменной нельзя
	// size1 := 5
	// var fs [size1]int //не скомпилируется
	const size2 = 5
	var fs [size2]int
	fmt.Println(fs) // [0,0,0,0,0]

	fmt.Println("-----------------------------------------------------------------------")

	//2) задать значения:

	var j [3]int = [3]int{1, 2, 3}
	b := [3]int{1, 2, 3}
	c := [...]int{1, 2, 3} //компилятор автоматически определит длину массива, не рекомендуется
	d := [3]int{1: 12}     //[index] : [value], дает задать конкретному элементу значение

	fmt.Println(j) // [1 2 3]
	fmt.Println(b) // [1 2 3]
	fmt.Println(c) // [1 2 3]
	fmt.Println(d) // [0 12 0]

	//3) операции
	// example := [10]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

	// example[5] = 11            //запись (при обращении к несуществующему или [-1] = panic)
	// example[6]                 //чтение
	// len(example)               //длина
	// cap(example)               //емкость
	// examplePointer := &example //указатель
	// s := example[1:4]          //срез

	fmt.Println("-----------------------------------------------------------------------")

	//4) сравнение массивов:
	//сравнивать можно только массивы одного типа (с одним типом данных и длиной)
	one := [3]int{1, 2, 3}
	two := [3]int{1, 2, 3}
	three := [3]int{3, 2, 1}

	fmt.Println(one == two)   // true
	fmt.Println(one == three) // false

	fmt.Println("-----------------------------------------------------------------------")

	//5) обращение к элементам
	//можно через цикл:
	z := [5]int{5, 10, 15, 20, 25}
	fmt.Println(z) // [5 10 15 20 25]

	for idx, elem := range z {
		fmt.Printf("Элемент с индексом %d: %d\n", idx, elem)
		// Элемент с индексом 0: 5
		// Элемент с индексом 1: 10
		// Элемент с индексом 2: 15
		// Элемент с индексом 3: 20
		// Элемент с индексом 4: 25
	}

	//одно из значений idx или elem можно опустить:
	for idx := range z {
		fmt.Println(z[idx]) // Вывод значений массива через индекс
	}

	for _, elem := range z {
		fmt.Println(elem) // Вывод значений напрямую
	}

	//range возвращает копию элемента массива, а не сам элемент.

	for _, elem := range z {
		elem = 100
		fmt.Println(elem)
		// 100
		// 100
		// 100
		// 100
		// 100
	}
	fmt.Println(z) // [5 10 15 20 25] - массив не изменился!

	for idx := range z {
		z[idx] = 100
		fmt.Println(z[idx])
		// 100
		// 100
		// 100
		// 100
		// 100
	}
	fmt.Println(z) // [100 100 100 100 100] - теперь массив изменился

	fmt.Println("-----------------------------------------------------------------------")

	/*
		- массив НЕ ЯВЛЯЕТСЯ указателем, это просто структура данных, занимающая определенную
		область памяти. Для каждого элемента есть адрес места памяти.

		Адрес:   0xA1  0xA2  0xA4  0xA6  0xA8  0xAA
				[ XX ][ 100][ 200][ 300][ 400][ XX ]

		array[idx] = *(array + idx * elem_size):
		• array[0] = *(array + 0 * 2) // *(0xA02 + 0 * 2) = 0xA2
		• array[1] = *(array + 1 * 2) // *(0xA02 + 1 * 2) = 0xA4
		• array[2] = *(array + 2 * 2) // *(0xA02 + 2 * 2) = 0xA6
		• array[3] = *(array + 3 * 2) // *(0xA02 + 3 * 2) = 0xA8


		- длина массива и размер элементов являются частью типа (эти данные нигде не хранятся).
	*/
}
