package main

//SLIDING_WINDOW
/*
Основная идея
Алгоритм работает путем перемещения окна фиксированного размера (обычно называется «окно») по массиву или строке.
Окно начинается с начала массива и постепенно сдвигается вправо на одну позицию, пока не достигнет конца. В каждом
положении окна выполняется необходимая операция (например, вычисление суммы элементов в окне, поиск максимума и т.
д.).

[2, 1, 5, 1, 3, 2]
- Сначала окно смотрит на [2, 1, 5].
- Затем оно сдвигается и смотрит на [1, 5, 1].
- Потом на [5, 1, 3], и так далее.

//--------------------------------------------------------------------------------------------------------------

Основные этапы алгоритма

1) Инициализация: Определите размер окна (обычно задается задачей) и начальную позицию.
2) Первичное вычисление: Вычислите значение для первого окна (например, сумму элементов окна, если это требуется задачей).
3) Сдвиг окна: Переместите окно на одну позицию вправо. Для нового положения окна обновите значение, добавив новый элемент
(который вошел в окно) и исключив старый элемент (который покинул окно).
4) Обработка каждого окна: В каждом новом положении окна выполняйте необходимую операцию (например, обновите максимальное
или минимальное значение, если это требуется).
5) Завершение: Продолжайте сдвигать окно, пока не достигнете конца массива или строки.

//--------------------------------------------------------------------------------------------------------------

Где можно использовать алгоритм
============================================================
 1. АНАЛИЗ ВРЕМЕННЫХ РЯДОВ
------------------------------------------------------------
• Задачи: Определение средних значений, трендов, отклонений и других
  характеристик временных рядов, таких как температурные данные,
  финансовые рынки или трафик в сети.

• Пример: Вычисление скользящего среднего за последние N дней
  для прогнозирования цены акций.
============================================================

 2. ОБРАБОТКА ПОТОКОВ ДАННЫХ
------------------------------------------------------------
• Задачи: Обработка данных в реальном времени, например, мониторинг
  сетевого трафика или отслеживание событий в IoT (интернет вещей).

• Пример: Обнаружение аномалий в сетевом трафике на основании анализа
  данных, поступающих за последние несколько секунд или минут.
============================================================

 3. ОПТИМИЗАЦИЯ ЗАДАЧ НА ПОДМАССИВЫ ИЛИ ПОДСТРОКИ
------------------------------------------------------------
• Задачи: Нахождение подмассивов или подстрок с особыми свойствами,
  такими как максимальная сумма, количество уникальных символов или
  нахождение палиндрома.

• Пример: Поиск подстроки фиксированной длины с максимальным количеством
  уникальных символов.
============================================================

 4. РАБОТА С ИЗОБРАЖЕНИЯМИ
------------------------------------------------------------
• Задачи: Обработка изображений, например, фильтрация шумов, нахождение
  краев или распознавание объектов.

• Пример: Применение фильтра для размытия изображения путём скользящего
  окна по каждому пикселю изображения и вычисления среднего значения
  соседних пикселей.
============================================================

 5. СЖАТИЕ ДАННЫХ
------------------------------------------------------------
• Задачи: Использование в алгоритмах сжатия данных, таких как LZ77,
  где окно скользит по тексту для нахождения повторяющихся паттернов.

• Пример: Уменьшение размера текста или изображения путём поиска
  и замены повторяющихся частей.
============================================================

 6. ОБРАБОТКА ЗВУКОВЫХ СИГНАЛОВ
------------------------------------------------------------
• Задачи: Анализ и фильтрация аудиосигналов, например, шумоподавление
  или выделение частотных характеристик.

• Пример: Применение фильтров низких частот для очистки звука
  в аудиофайле.
============================================================

 7. РАБОТА С БОЛЬШИМИ ДАННЫМИ
------------------------------------------------------------
• Задачи: Быстрая обработка больших массивов данных, например,
  для аналитики или машинного обучения.

• Пример: Расчёт скользящего среднего для больших наборов данных,
  таких как веб-логи, для анализа трафика на сайте.
============================================================

 8. ПОИСК ПАТТЕРНОВ
------------------------------------------------------------
• Задачи: Обнаружение паттернов или шаблонов в последовательных данных.

• Пример: Поиск аномальных действий пользователя на основе его
  предыдущих действий.
============================================================

 9. ОПТИМИЗАЦИЯ АЛГОРИТМОВ
------------------------------------------------------------
• Задачи: Улучшение производительности алгоритмов, которые работают
  с последовательными данными.

• Пример: Ускорение поиска подстроки в строке с использованием
  скользящего окна вместо полного перебора всех возможных вариантов.
============================================================
*/

//--------------------------------------------------------------------------------------------------------------

//Пример:
/*
	1) Инициализация: Мы сначала проверяем, что размер массива больше или равен размеру окна k.
	2) Первое окно: Вычисляем сумму первых k элементов массива, чтобы инициализировать windowSum.
	3) Сдвиг окна: Начинаем сдвигать окно, добавляя новый элемент и убирая старый, обновляя сумму на каждом шаге.
	4) Максимальная сумма: В процессе сдвига окна мы обновляем значение maxSum, если текущая сумма окна больше
	предыдущей.
	- это оптимизированный поиск
*/
//сложность - O(n) (линейная)
func maxSumSubarray(arr []int, k int) int {
	if len(arr) < k {
		panic("Размер окна должен быть меньше или равен длине массива")
	}

	// Сумма первого окна
	windowSum := 0
	for i := 0; i < k; i++ {
		windowSum += arr[i]
	}

	maxSum := windowSum

	// Сдвигаем окно
	for i := k; i < len(arr); i++ {
		windowSum += arr[i] - arr[i-k] //оптимизированный поиск
		if windowSum > maxSum {
			maxSum = windowSum
		}
	}

	return maxSum
}

func main() {}
