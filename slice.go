package main

import "fmt"

func main() {

	/*
		Срез — это последовательность элементов одного типа, но в отличие от массива,
		его длина может изменяться.  Фактически, срез представляет собой структуру,
		которая предоставляет доступ к определённой части базового массива.

		Срез состоит из трёх основных компонентов:
		1) Указатель (pointer) — ссылается на первый элемент массива, доступный через срез (он
		может не совпадать с началом самого массива).
		2) Длина (length) — количество элементов в срезе.
		3) Емкость (capacity) — общее количество элементов от начала среза до конца базового
		массива.

		Определить длину и емкость среза можно с помощью встроенных функций len() и cap()
		соответственно.

		- срез по сути - указатель на массив
		- срез можно создать на основе массива, либо просто так
		- когда мы создаем срез, он ссылается на какой-то массив. Если мы создаем срез из
		массива, то он ссылается на него.
		- срез, созданный на основе массива, имеет capacity (емкость), которая равна длина
		массива - индекс, с которого мы начали срезать
		- если мы будем менять срез, то изменится и массив, на который он ссылается
		- если мы добавим элементов в срез, в котором недостаточно capacity, то он перестанет
		ссылаться на тот массив, в памяти будет создан новый массив, в который скопируется
		старый + новые элементы. Поэтому старый массив больше мутировать не будет.
	*/

	//1) создать срез
	// Срез можно создать так же, как массив, но без указания длины, поскольку она изменяемая.
	// При этом можно сразу инициализировать срез, указав его элементы.

	var a []int //пуст, длина = 0
	var b []int = []int{2, 4, 6}
	c := []int{2, 4, 6}
	d := []int{2: 10} //явно задали элемент с индексом 2

	fmt.Println(a) // []
	fmt.Println(b) // [2 4 6]
	fmt.Println(c) // [2 4 6]
	fmt.Println(d) // [0 0 10]

	fmt.Println("-----------------------------------------------------------------------")

	//2) можно использовать make([]T, length, capacity)
	/*
		При создании среза через make в памяти выделяется базовый массив, а срез получает к нему
		доступ. Его указатель ссылается на первый элемент массива, а длина и емкость определяются
		в зависимости от переданных параметров.

		Для чего может понадобиться явное указание длины и емкости?
		- Чтобы инициализировать элементы среза нулевыми значениями (длина).
		- Чтобы заранее выделить нужное количество памяти для массива, лежащего в основе среза.


		Если потом добавлять элементы, и превысить capacity среза, то GO создаст новый массив
		большего размера. Это дороже по ресурсам, чем сразу выделить с запасом.
	*/

	q1 := make([]int, 5, 10) //имеет длину 5, но базовый массив может вместить до 10 элементов
	fmt.Println(q1)          // [0 0 0 0 0]
	q2 := make([]int, 65)    //имеет длину 65, емкость тоже 65 (длина=емкость)
	fmt.Println(q2)

	fmt.Println("-----------------------------------------------------------------------")

	//3) оператор среза
	/*
		s[i:j]
		- создаёт новый срез на основе последовательности s, содержащий элементы с индекса i по
		j-1
		- должно выполняться условие 0 <= i <= j <= cap(s)
		- если i не указан, он по умолчанию равен 0
		- если j не указан, используется длина исходной последовательности s
		- полученный срез содержит j - i элементов
	*/

	baseArray := [8]string{"Anna", "Max", "Eva", "Leo", "Nina", "Tom", "Sophie", "Chris"}

	slice1 := baseArray[1:5] // со 2-го по 5-й элемент
	slice2 := baseArray[:3]  // с 1-го по 3-й элемент
	slice3 := baseArray[4:]  // с 5-го до конца

	fmt.Println(slice1) // [Max Eva Leo Nina]
	fmt.Println(slice2) // [Anna Max Eva]
	fmt.Println(slice3) // [Nina Tom Sophie Chris]

	fmt.Println("-----------------------------------------------------------------------")

	//4) append
	/*
		append - добавляет элементы в срез

		func append(slice []Type, elems ...Type) []Type

		slice - срез, в который добавлются элементы
		[]Type, elems ...Type - это элементы такого же типа, что и срез, которые необходимо
		добавить. Можно добавить либо срез, либо передать как несколько аргументов нужные
		элементы для добавления.

		- возвращает новый срез, включающий исходные элементы и добавленные значения
		- в go нет функции для удаления элементов из среза, но можно сделать это с помощью
		append, создав новый массив из старого:
			a := []int{1, 2, 3, 4, 5, 6, 7}
			a = append(a[0:2], a[3:]...)
			fmt.Println(a) // [1 2 4 5 6 7] - удалили элемент 3 под индексом 2
	*/

	numbers := []int{10, 20, 30}
	numbers = append(numbers, 40, 50)

	fmt.Println(numbers) // [10 20 30 40 50]

	fmt.Println("-----------------------------------------------------------------------")

	//5) что будет, если добавить больше элементов, чем емкость массива?

	baseArrayA := [10]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
	fmt.Printf("Базовый массив: %v\n", baseArrayA)

	//ссылается на массив. если будем менять его - то поменяется и массив.
	baseSlice := baseArrayA[5:8]
	fmt.Printf(
		"Срез, основанный на базовом массиве длиной %d и емкостью %d: %v\n",
		len(baseSlice),
		cap(baseSlice),
		baseSlice,
	)

	// Output:
	// Базовый массив: [0 1 2 3 4 5 6 7 8 9]
	// Срез, основанный на базовом массиве длиной 3 и емкостью 5: [5 6 7]
	/* емкость 5, так как емкость - общее количестов элементов от начала среза (5 индекс) до конца
	базового массива (10 индекс) */

	fmt.Println("-----")

	//указатель
	/*
		Конструкция %p говорит, что в качестве результата должен быть возвращен адрес элемента
		массива, на который ссылается baseSlice.
	*/
	pointer := fmt.Sprintf("%p", baseSlice)

	//добавили один элемент - 10
	baseSlice = append(baseSlice, 10)
	fmt.Printf("Массив: %v\n", baseArrayA)
	fmt.Printf("Срез длиной %d и емкостью %d: %v\n", len(baseSlice), cap(baseSlice), baseSlice)
	fmt.Println(pointer == fmt.Sprintf("%p", baseSlice))

	// Output:
	// Массив: [0 1 2 3 4 5 6 7 10 9] - изменился! (было [0 1 2 3 4 5 6 7 8 9])
	// Срез длиной 4 и емкостью 5: [5 6 7 10]
	// true

	fmt.Println("-----")

	//добавили элементов столько, чтобы емкости не хватило
	baseSlice = append(baseSlice, 11, 12, 13)
	fmt.Printf("Массив: %v\n", baseArrayA)
	fmt.Printf("Срез длиной %d и емкостью %d: %v\n", len(baseSlice), cap(baseSlice), baseSlice)
	fmt.Println(pointer == fmt.Sprintf("%p", baseSlice))

	// Output:
	// Массив: [0 1 2 3 4 5 6 7 10 9] - не изменился!
	// Срез длиной 7 и емкостью 10: [5 6 7 10 11 12 13]
	// false

	//теперь срез ссылается на другой массив!
	/*
		при добавлении новых элементов в срез go проверяет, осталось ли достаточно емкости среза
		(то есть есть ли еще место в массиве, на который он ссылается). Если емкости недостаточно -
		создается новый срез, который ссылается на массив большего объема, в который копируются
		все элементы из старого среза, а так же добавляются новые.
	*/

	fmt.Println("-----------------------------------------------------------------------")

	//6) copy
	/*
		func copy(dst, src []Type) int

		dst - срез-назначение
		src - срез-источник того же типа, что и срез-назначение

		- возвращает число скопированных элементов
	*/

	aA := []int{1, 2, 3}    //[1,2,3]
	bA := make([]int, 3, 3) //[0,0,0]
	nA := copy(bA, aA)      //копируем А в Б

	fmt.Printf("a = %v\n", aA)                  // a = [1 2 3]
	fmt.Printf("b = %v\n", bA)                  // b = [1 2 3]
	fmt.Printf("Скопировано %d элемента\n", nA) // Скопировано 3 элемента

	fmt.Println("-----------------------------------------------------------------------")

	//7) особенности с функциями
	/*

		func A:
		•	Тип параметра — массив фиксированной длины [3]int.
		•	В Go массивы передаются по значению, то есть создаётся копия массива.
		•	Изменения внутри fnA затрагивают только копию, оригинальный массив a в main остаётся без
		изменений.

		func B:
		•	Тип параметра — срез []int.
		•	В Go срез — это структура, содержащая указатель на массив, длину и ёмкость.
		•	Когда срез передаётся в функцию, копируется структура, но указатель внутри указывает на тот
		же массив, что и в вызывающем коде.
		•	Поэтому изменения по индексу влияют на оригинальные данные.



		func fnA(a [3]int) {
			a[1] = 15
		}

		func fnB(a []int) {
			a[1] = 15
		}

		func main() {
			a := [3]int{1, 2, 3}
			b := []int{1, 2, 3}

			fnA(a)
			fnB(b)

			fmt.Println(a) // [1 2 3]
			fmt.Println(b) // [1 15 3]
		}
	*/

	fmt.Println("-----------------------------------------------------------------------")

	//8) распаковка среза
	/*
		... (многоточие) - можно использовать как инструмент для распаковки среза, то есть передачи
		элементов как отдельных аргументов.
	*/

	s := []interface{}{1, 2, 3, 4, 5}
	fmt.Println(s)    // Выводит: [1 2 3 4 5]
	fmt.Println(s...) // Выводит: 1 2 3 4 5

	//можно объеденить массивы с помощью многоточия, то есть передать элементы массива как аргументы
	s1 := []int{1, 2, 3, 4, 5}
	s2 := []int{6, 7, 8, 9, 10}

	s1 = append(s1, s2...) //[1 2 3 4 5 6 7 8 9 10]
	fmt.Println(s1)

}
