package main

import (
	"context"
	"fmt"
	"io"
	"log"
	"math/rand"
	"net/http"
	"sync"
	"time"
)

//Контекст
/*
	Пакет context определяет тип Context, который позволяет управлять дедлайнами, сигналами отмены и другими значениями
	области действия запросов между границами API и процессами.
	ИЛИ
	Это объект, который предназначен в первую очередь для того, чтобы иметь возможность отменить извне выполнение потенциально
	долгой операции. Кроме того, с помощью контекста можно хранить и передавать информацию между функциями и методами внутри
	программы.

	1) отмена операций:
		- по явному сигналу отмены (context.WithCancel)
		- по истечению промежутка времени (context.WithTimeout)
		- по наступлению временной отметки или дедлайна (context.WithDeadline)
	Позволяет избежать утечки горутин (ситуаций, когда горутина продолжает свое выполнение, но результат
	ее работы уже никого не интересует).
	2) передача данных:
		- context.Value
*/

//----------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------

// context.WithTimeout()
/*
	Ваше приложение отправляет запрос во внешнюю систему, например, в API другого сервиса, который владеет интересующими вас данными.
	Так как мы не контролируем  внешние системы, мы не можем быть на 100% уверены, что API ответит за приемлемое время, или вообще
	ответит когда-либо. Чтобы не зависнуть навечно в ожидании ответа от API, в запрос можно передать контекст:
*/
/*
Контекст с таймаутом по сути является удобной обёрткой над контекстом с дедлайном (можно просто выразить время через добавление к
текущему моменту - time.Now().Add(15*time.Second))
*/
func withTimeout() {
	//инициализация контекста с таймаутом в 15 секунд.
	ctx, cancel := context.WithTimeout(context.Background(), 15*time.Second) //через 15 секунд будет Done, и больше не будем дожидаться ответа
	/*
		Конструкция defer cancel() гарантирует, что после выхода из функции или горутины контекст будёт отменён, и таким образом вы избежите
		утекания горутины — явления, когда горутина продолжает выполняться и существовать в памяти, но результат её работы больше никого не
		интересует.
	*/
	defer cancel()

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, "https://example.com", nil)
	if err != nil {
		fmt.Printf("failed to create request with ctx: %w", err)
	}

	res, err := http.DefaultClient.Do(req)
	if err != nil {
		fmt.Printf("failed to perform http request: %w", err)
	}

	fmt.Printf("result is", res)
}

//----------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------

//Дерево контекста
/*
	Дерево контекста
	любой контекст должен наследоваться от какого-то другого контекста (за исключением Background и TODO -
	они являются заглушками, используется как верхний родитель. Они абсолютно одинаковые, разница в них только
	семантическая.).
	Background - используется как верхний родитель для всех других контекстов.
	TODO - используется как верхний родитель когда мы не определили, какой тип контекста хотим использовать (
	указывает, что если есть TODO - значит, скорее всего, там будет логика работы с контекстом).

	Это сделано для того, чтобы в функции, куда был проброшен контекст, не было возможности повлиять на условия
	отмены сверху. Это является гарантией, что контекст с дедлайном отменятся не позже данного дедлайна. Так же
	это дает возможность передавать контекст дальше по цепочке и обогощать его новыми данными.
*/
/*
							    context.Background                    context.TODO
			                      /       \
			                     /         \
			     context.WithCancel     context.WithValue
			           /     \
			          /       \
	context.WithTimeout   context.WithDeadline
*/
/*
	Если у родительского контекста вызвать cancel, то все его дети тоже закроются.

*/

/*
	Несмотря на то, что внутри функции doWorkTree таймаут переопределяется на больший, отмена контекста все равно наступит
	через 10 секунд.
*/

func Tree() {
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	doWorkTree(ctx)
}

func doWorkTree(ctx context.Context) {
	newCtx, cancel := context.WithTimeout(ctx, 30*time.Second) //все равно отменится через 10 секунд! так как родитель определил так
	defer cancel()

	log.Println("starting working...")

	for {
		select {
		case <-newCtx.Done():
			log.Printf("ctx done: %v", ctx.Err())
			return
		default:
			log.Println("working...")
			time.Sleep(1 * time.Second)
		}
	}
}

//----------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------

//context.WithDeadline()

/*
	time.Now().Add(10*time.Second) — это ровно то, что делает функция context.WithTimeout(), вызывая внутри себя context.WithDeadline()
*/

func withDeadline() {
	ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(10*time.Second))
	defer cancel()

	doWork(ctx)
}

func doWork(ctx context.Context) {
	newCtx, cancel := context.WithTimeout(ctx, 30*time.Second) //все равно отменится через 10 секунд!
	defer cancel()

	log.Println("starting working...")

	for {
		select {
		case <-newCtx.Done():
			log.Printf("ctx done: %v", ctx.Err())
			return
		default:
			log.Println("working...")
			time.Sleep(1 * time.Second)
		}
	}
}

//----------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------

//context.WithCancel()
/*
	Контекст с функцией отмены. Тут происходит гонка - в каком сервисе быстрее всего найдется машина. Как только
	машина нашлась - нужно отменить поиски всех остальных машин.>

*/

func doCancel() {
	var (
		resultCh    = make(chan string)
		ctx, cancel = context.WithCancel(context.Background())
		services    = []string{"Super", "Villagemobil", "Sett Taxi", "Index Go"}
		wg          sync.WaitGroup
		winner      string
	)

	defer cancel()

	for i := range services {
		svc := services[i]

		wg.Add(1)
		go func() {
			requestRide(ctx, svc, resultCh)
			wg.Done()
		}()
	}

	go func() {
		winner = <-resultCh //заблокируется до тех пор, пока не найдется победитель. когда он найдется - контекст отменится!
		cancel()
	}()

	wg.Wait()
	fmt.Printf("found car in %q", winner)

}

func requestRide(ctx context.Context, serviceName string, resultCh chan string) {
	time.Sleep(3 * time.Second)

	for {
		select {
		case <-ctx.Done(): //какая-то машина уже нашлась! отменяем поиск:
			fmt.Printf("stopped the search in %q (%v)\n", serviceName, ctx.Err())
			return
		default:
			if rand.Float64() > 0.75 {
				resultCh <- serviceName
				return
			}

			continue
		}
	}
}

//----------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------

//context.WithValue()

/*
	Передача данных через контекст.
*/

func withValue() {
	ctx := context.WithValue(context.Background(), "name", "Joe")

	/*
		метод Value возвращает значение типа interface{}, поэтому придется приводить его к нужному типу. Если такого ключа
		нет - метод вернет nil.
		Когда стоит передавать данные через контекст?
		Короткий ответ — никогда. Передача данных через контекст является антипаттерном, поскольку это порождает неявный
		контракт между компонентами вашего приложения, к тому же ещё и ненадёжный. Исключение составляют случаи, когда вам
		нужно предоставить компоненту из внешней библиотеку вашу реализацию интерфейса, который вы не можете менять. Например,
		middleware в HTTP сервере.
	*/
	log.Printf("name = %v", ctx.Value("name"))
	log.Printf("age = %v", ctx.Value("age"))
}

/*
	Пример. HTTP Middleware
	Представьте, что вы хотите, чтобы ваш API принимал запросы только от аутентифицированных клиентов. Однако вызывать методы для
	аутентификации в каждом обработчике не кажется удачной идеей. Но вы можете сделать так, чтобы перед тем как вызовется обработчик
	запроса, вызвался метод, который проведёт аутентификацию, и либо вызовет следующий метод в цепочке (в данном случае обработчик),
	либо вернёт HTTP с ошибкой аутентификации. Это и есть пример классического middleware.
*/

func middlewareUser() {
	mux := http.NewServeMux()

	mux.Handle("/restricted", authMiddleware(handleRestricted()))

	if err := http.ListenAndServe(":3000", mux); err != nil {
		log.Fatal(err)
	}
}

type ctxKey string

const keyUserID ctxKey = "user_id"

func authMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		token := r.Header.Get("Token")

		if token != "very-secret-token" {
			w.WriteHeader(http.StatusUnauthorized)
			io.WriteString(w, "invalid token")
			return
		}

		ctx := context.WithValue(r.Context(), keyUserID, 42)
		next.ServeHTTP(w, r.WithContext(ctx))
	})
}

func handleRestricted() http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		userID, ok := r.Context().Value(keyUserID).(int)
		if !ok {
			w.WriteHeader(http.StatusInternalServerError)
			io.WriteString(w, "internal error, try again later please")
			return
		}

		io.WriteString(w, fmt.Sprintf("hello, user #%d!", userID))
	})
}

//----------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------

/*
	Когда использовать контекст?
	- Метод ходит куда-то по сети;
	- Горутина исполняется потенциально «долго».
	Если у вас есть сомнения насчёт того, соответствует ли функция одному из этих критериев, то лучше всё-таки добавить контекст.
	Это не усложнит вам жизнь, но потенциально упростит её в будущем. Особенно это касается объявляемых вами интерфейсов — внутри
	реализации может происходить всё что угодно, в том числе сетевые вызовы и долгие операции.
*/

//----------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------

/*
	ПРАВИЛА:
	1) Передавайте контекст всегда первым аргументом — это общепринятое соглашение;
	2) Передавайте контекст только в функции и методы, не храните в состоянии (внутри структуры). Контексты спроектированы так, чтобы
	их использовали как одноразовые и неизменяемые объекты. Например, если вы сохраните контекст с таймутом в 15 секунд в поле структуры,
	а спустя 15 секунд попробуете выполнить операцию с данным контекстом, у вас ничего не получится. Обнулить счётчик таймаута вы тоже
	не сможете;
	3) Используйте context.WithValue только в крайних случаях. В 99,(9)% случаев вы сможете передать данные через аргументы функции;
	4) context.Background должен использоваться только как самый верхний родительский контекст, поскольку он является заглушкой и не
	предоставляет средств контроля;
	5) Используйте context.TODO, если пока не уверены, какой контекст нужно использовать;
	6) Не забывайте вызывать функцию отмены контекста, т.к. функции, принимающей контекст может потребоваться время на завершение перед
	выходом;
	7) Передавайте только контекст, без функции отмены. Контроль за завершением контекста должен оставаться на вызывающей стороне, иначе
	логика приложения может стать очень запутанной.
*/

//----------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------

func main() {

	fmt.Println("----------------------------------------------------------------------------------------------------------------")

	fmt.Println("context.WithTimeout()")
	withTimeout()

	fmt.Println("----------------------------------------------------------------------------------------------------------------")

	fmt.Println("Context Tree")
	Tree()

	fmt.Println("----------------------------------------------------------------------------------------------------------------")

	fmt.Println("context.WithDeadline()")
	withDeadline()

	fmt.Println("----------------------------------------------------------------------------------------------------------------")

	fmt.Println("context.WithCancel()")
	doCancel()

	fmt.Println("----------------------------------------------------------------------------------------------------------------")

	fmt.Println("context.WithValue()")
	withValue()
	middlewareUser()
}
