package main

import "fmt"

type Liters float64
type Gallons float64

func main() {
	/*
		ОПРЕДЕЛЯМЫЕ ТИПЫ позволяют четко обозначить, для чего должно использоваться их
		значение. Базовый тип может быть создан на основе другого любого типа - string, int, bool
		и даже структуры.

	*/

	var gallons Gallons
	var liters Liters

	var carFuel Gallons
	var busFuel Liters

	//1) мы не можем присвоить переменной определяемого типа значение другого определяемого типа, даже
	// если "под капотом" они одинаковые
	// carFuel = busFuel //ОШИБКА!
	// НО можно преобразовать:
	// carFuel = Gallons(busFuel) * 3.785

	carFuel = Gallons(10.0)
	busFuel = Liters(240.0)

	fmt.Println(carFuel, busFuel) //10, 240

	gallons = Liters(2).ToGallons()
	liters = Gallons(2).ToLiters()

	fmt.Println(gallons, liters) //0.528, 7.57

	//2) для определяемого типа можно определить метод (определены за пределами main)
	/*
		чтобы взять значение переменной определяемого типа - нужно к обычной функции добавить параметр получателя,
		он и есть значение (копия значения).
		Чтобы получить само значение - нужно добавить * (передавать ссылку на значение, а не его копию), Go
		автоматически передает указатель, а не копию, если мы так указали:

		func (l *Liters) ChangeV() {
			*l += 1
		}

		l := Liters(5)
		l.ChangeV()
		fmt.Println(l) //6

		Для единства стиля у всех методов типа получателем должно быть либо значение, либо указатель; смешивать их
		не рекомендуется.
	*/

}

func (l Liters) ToGallons() Gallons {
	return Gallons(l * 0.264)
}

func (g Gallons) ToLiters() Liters {
	return Liters(g * 3.785)
}

/*
	3) ОШИБКИ
	Вы можете получать указатели только на значения, хранящиеся в переменных. При попытке получить адрес значения,
	не хранящегося в переменной, вы получите сообщение об ошибке:
	&MyType("a value")
	- cannot take the address of MyType("a value")

	То же ограничение действует при вызове методов с получателями-указателями. Go может автоматически преобразовать
	значения в указатели, но только если значение указателя хранится в переменной. При попытке вызвать метод для самого
	значения Go не сможет получить указатель, и вы получите похожую ошибку:
	MyType("a value").pointerMethod()
	- cannot call pointer method on MyType("a value") && cannot take the address of MyType("a value")

	Вместо этого нужно сохранить значение в переменной; это позволит Go получить указатель на нее:
	value := MyType("a value")
	value.pointerMethod() // <- Go преобразует значение в указатель.
*/
