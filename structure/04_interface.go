package main

import "fmt"

type Dog struct {
	Name string
}

func (d *Dog) Speak() string {
	return "Гав! Меня зовут " + d.Name
}

/*
ИНТЕРФЕЙС - это специальный тип, который определяет набор сигнатур методов, но не содержит их реализацию.
Интерфейсы позволяют описывать поведение структур, что делает код более гибким. Структуры могут НЕЯВНО
реализовывать интерфейсы. Интерфейсы позволяют писать гибкий и расширяемый код, который работает с абстракциями,
а не с конкретными структурами. Они только описывают, что значение может делать, то есть какие методы оно содержит.
ПРИМЕР:
Неважно, работаем ли мы с Pen или Pencil, нам нужно просто выполнить Draw (два разных типа с одинаковым
методом).

Любой тип, который содержит все методы, перечисленные в определении интерфейса, называется поддерживающим этот
интерфейс. Тип, поддерживающий интерфейс, может использоваться в любом месте, где должен использоваться этот интерфейс.
Тип может содержать методы помимо тех, которые перечислены в интерфейсе, но в нем не могут отсутствовать такие методы,
иначе тип не будет поддерживать интерфейс. Пример:
*/
type MyInterface interface {
	MethodWithoutParameters()
	MethodWithParameter(float64)
	MethodWithReturnValue() string
}

type MyType int

func (m MyType) MethodWithoutParameters() {
	fmt.Println("MethodWithoutParameters called")
}
func (m MyType) MethodWithParameter(f float64) {
	fmt.Println("MethodWithParameter called with", f)
}
func (m MyType) MethodWithReturnValue() string {
	return "Hi from MethodWithReturnValue"
}
func (my MyType) MethodNotInInterface() {
	fmt.Println("MethodNotInInterface called")
}

/*
	Многие другие языки требуют явно указать, что MyType поддерживает MyInterface. Но в Go это происходит автоматически. Если тип
	содержит все методы, объявленные в интерфейсе, то может находиться в любом месте, где должен использоваться этот интерфейс, без
	каких-либо дополнительных объявлений.
*/

func main() {

	//ПЕРЕМЕННАЯ ИНТЕРФЕЙСНОГО ТИПА

	var v MyInterface
	v = MyType(5) //myType поддерживают инферфейс MyInterface, поэтому это значение может быть присвоено переменной с типом MyInterface
	v.MethodWithParameter(12)
	v.MethodWithReturnValue()
	v.MethodWithoutParameters()

	//1) вызов метода у переменной интерфейсного типа
	/*
		значение интерфейсного типа != nil, когда конкретный тип (структура) != nil (type <nil>). Мы можем безопасно
		вызвать метод у интерфейса только в случае, когда значение интерфейсного типа != nil (type <nil>). В противном
		случае мы словим панику.
	*/

	// var a Animal
	// // a.Speak() //паника!
	// a = &Dog{} //присвоили
	// a.Speak()  //ok

	//2) вызов метода, отсутствующего в интерфейсе у переменной интерфейсного типа
	/*
		после того как значение будет присвоено переменной (или параметру метода) с типом интерфейса, для нее можно
		будет вызывать только те методы, которые определяются интерфейсом.
	*/
	var c MyInterface
	c = MyType(10)
	c.MethodWithParameter(3) //ok
	// c.MethodNotInInterface() //c.MethodNotInInterface undefined (type MyInterface has no field or method MethodNotInInterface)

	//3)
	/*
		Если тип объявляет методы с указателямина получателей, при присваивании переменным с типом интерфейса можно будет использовать
		только указатели на этот тип.

		package main

		import "fmt"

		type Switch string

		func (s *Switch) toggle() { //toggle - метод указателя!
			if *s == "on" {
					*s = "off"
			} else {
					*s = "on"
			}
			fmt.Println(*s)
		}

		type Toggleable interface {
			toggle()
		}

		func main() {
			s := Switch("off")
			var t Toggleable = s
			t.toggle()
			t.toggle()
		}

		- ошибка Switch does not implement Toggleable (toggle method has pointer receiver).

		Ошибка происходит потому что метод toggle для типа Switch должен использовать указатель на получателя, чтобы
		он мог изменить получателя.
		В Go, когда ты хочешь, чтобы какая-то переменная соответствовала интерфейсу (то есть реализовывала все методы
		интерфейса), Go проверяет методы этого значения. Если ты передаёшь значение типа (например, s, а не &s), Go
		смотрит только на методы, определённые для значения (без * перед получателем). Методы, у которых получатель —
		указатель (например, func (s *Switch) toggle()), не учитываются.

		•	У тебя есть метод toggle(), определённый так: func (s *Switch) toggle(), то есть он работает только с указателями.
		•	Когда ты пишешь var t Toggleable = s, ты передаёшь значение s, не указатель.
		•	Go проверяет: “А реализует ли значение s метод toggle()?” — и не находит его, потому что toggle() — метод
		указателя, а не значения.
		•	Go выдает ошибку: “Switch не реализует Toggleable”.

		Таким образом, проблема решается присваиванием переменной Toggleable указателя на Switch вместо непосредственного
		значения Switch:

		var t Toggleable = &s

	*/

	fmt.Println("----------------------------------------------------------------------------------------------------------------")

	//ПОД КАПОТОМ

	/*
		Когда ты присваиваешь что-то переменной интерфейсного типа, Go не просто сохраняет значение, а делает две вещи
		одновременно:
		1.	Запоминает конкретный тип (например, Dog, int, string, *User и т.п.)
		2.	Сохраняет само значение этого типа
		можно рассматривать как кортеж (пару) из значения и конкретного типа:

		(value, type)
		type - конкретный тип данных, к которому принадлежит значение. Например, это может быть строка (string), число
		(int), структура (struct) или любой другой тип. Тип определяет, какие методы доступны для вызова на этом
		значении.
		value - конкретное значение, которое принадлежит определенному базовому типу. Например, это может быть строка
		"Hello", число 123 или экземпляр структуры, такой как Dog.
	*/

	type Animal interface {
		Speak() string
	}
	var animal Animal
	fmt.Printf("Value %v, type %T\n", animal, animal) //Value <nil>, type <nil>
	//Это означает, что переменная animal не содержит никаких свойств и не указывает на конкретный тип (структуру).

	if animal != nil {
		fmt.Println("animal is not nil") //никогда не распечатается
	}

	dog := &Dog{} //указатель на новый объект Dog
	animal = dog
	animal.Speak()                                    //можем вызвать, так как dog реализует этот метод (то есть имплементирует интерфейс)
	fmt.Printf("Value %v, type %T\n", animal, animal) //Value &{}, type *main.Dog - теперь тип указывает на Dog

	if animal != nil {
		fmt.Println("animal is not nil") //распечатается
	}
	// Поскольку animal указывает на объект Dog, условие выполняется, и выводится сообщение "animal is not nil".

	dog.Name = "Шайтан"
	fmt.Printf("Value %v, type %T\n", animal, animal) //Value &{Шайтан}, type *main.Dog - выводит новоиспеченное св-во

	//как go хранит "под капотом" значение интерфейсного типа?
	/*
		когда в go объявляем значение интерфейсного типа:
		var animal Animal

		go создает объект интерфейса (именно в момент объявления значения интерфейсного тирп). Внутри, интерфейс - это
		связка:
		•	указателя на данные, которые интерфейс содержит.
		•	указателя на таблицу методов, соответствующую конкретному типу.
		Для этого Go использует структуру iface (упрощенно) (исходники runtime GO src/runtime/runtime2.go):
		type iface struct {
			tab  *itab
			data unsafe.Pointer
		}
		tab -  это указатель на Interface Table или itable - структуру, которая хранит некоторые метаданные о типе и
		список методов, используемых для удовлетворения интерфейса (указатель на таблицу методов (и тип)).
		data - хранимые данные (указатель на значение)

		itab - это то, что "связывает" интерфейс и конкретный тип:
		type itab struct {
			inter *interfacetype  // описание интерфейса
			_type *_type          // описание реального типа
			hash  uint32
			_     [4]byte         // padding
			fun   [1]uintptr      // таблица методов (vtable)
		}



		РЕАЛЬНЫЙ ПРИМЕР:
		type Animal interface {
			Speak() string
		}

		type Dog struct{}

		func (Dog) Speak() string {
			return "Woof"
		}

		var a Animal = Dog{}

		ВНУТРИ:
		•	создаётся itab, которая говорит: «Dog реализует Animal, вот метод Speak».
		•	создаётся iface:
			•	tab → указывает на itab
			•	data → указывает на значение Dog{}

		- позволяет понимать, как работает приведение типов, вызов методов через интерфейс и почему интерфейсы “дороже”
		по памяти и CPU

	*/

	fmt.Println("----------------------------------------------------------------------------------------------------------------")

	//УТВЕРЖДЕНИЯ ТИПА (type assertion)
	/*
		Утверждение типа помогает использовать методы, которых нет в интерфейсе, но есть в типе.
	*/

	var mi MyInterface = MyType(25)
	mt, ok := mi.(MyType) //ok отдаст boolean, успешно ли утверждение
	if ok {
		mt.MethodNotInInterface() //ok, все работает
	}

	/*
		где :
		mi - значение типа интерфейса
		MyType - проверяемый тип
		ok - флаг успешно ли приведение
	*/

	fmt.Println("----------------------------------------------------------------------------------------------------------------")

	//ВСТРОЕННЫЕ ИНТЕРФЕЙСЫ

	//Stringer
	/*
		пакет fmt определяет интерфейс fmt.Stringer: чтобы любой тип мог решить, как он должен отображаться при выводе.
		Определение интерфейса выглядит так:

		type Stringer interface {
			String() string
		}

		Получается, что любой тип, у которого есть метод String, возвращающий строку - поддерживает интерфейс Stringer,
		и тогда функции из пакета fmt будут проверять, если переданные ему значения поддерживают этот интерфейс - то он
		вызовет метдо String для этого значения.

		type CoffeePot string

		func (c CoffeePot) String() string {
			return string(c) + " coffee pot"
		}

		func main() {
			coffeePot := CoffeePot("LuxBrew")
			fmt.Println(coffeePot.String())   //LuxBrew coffee pot
			fmt.Print(coffeePot, "\n")        //LuxBrew coffee pot
			fmt.Println(coffeePot)            //LuxBrew coffee pot
			fmt.Printf("%s", coffeePot)       //LuxBrew coffee pot
		}

		Многие функции из пакета fmt проверяют, поддерживают ли переданные им значения интерфейс Stringer, и если поддерживают
		— вызывают их методы String, а возвращаемые значения будут использоваться в выводе.
	*/

	//ПУСТОЙ ИНТЕРФЕЙС
	/*
		тип значения - interface{} означает ЛЮБОЕ ЗНАЧЕНИЕ.
		Интерфейс определяет, какие методы должен содержать тип, чтобы ему удовлетворять. Так как интерфейс пустой, то ему
		будет удовлетворять ЛЮБОЙ тип. Чтобы как-то с ним взаимодействовать - придется использовать утверждение типов.
	*/

	acceptAnything := func(v interface{}) {}

	acceptAnything(3.5555)   //ok
	acceptAnything("string") //ok
	acceptAnything(false)    //ok
	acceptAnything(22)       //ok
	acceptAnything(nil)      //ok

}
